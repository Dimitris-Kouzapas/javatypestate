\section{Typestates as annotated interfaces}

The first typestate experiments such as Plural \cite{bierhoff11} used
pre- and post-condition annotations on methods to specify state
transitions. More recent ``typestate-oriented'' efforts such as Plaid
\cite{garcia14} unify states with classes. In these languages state
change amounts to object reclassification, which is not supported in
Java.

Our current approach is similar to the first approach but utilises a
separate typestate definition. Merits aside, a distinct notion of
typestate definition introduces unneeded complexity into the
programming model and language design: both the user, and our
compiler, are forced to consider the interaction between typestate
definitions and the Java definitions they relate to. For example, we
must resolve language definition issues like the following:

\begin{itemize}
\item Can I overload typestate methods (e.g. have two methods called
  \ttt{buy})?
\item When is a Java definition is deemed to ``match'' a typestate
  definition?
\item How to extend typestate with features like inheritance or exceptions?
\item Can I use a typestate definition as an interface or vice versa?
\end{itemize}

\noindent A more practical strategy would be to utilise and extend
Java's existing notions of interface and method signature, leveraging
the rules Java already uses to answer such questions. An additional
advantage is that IDE features like refactoring that work with
specific language features will have some chance of working with our
proposed extensions. One way to extend Java in a backwards-compatible
way is to use \emph{annotations}. Such an approach is outlined below.

\subsection{Typestate via annotations}

An interface specifies the methods available on an object. Since this
is what a typestate also does, our strategy will be to represent a
typestate as an interface where each method is \emph{annotated} with a
specification of the state that it transitions the object to. An
annotation is a backwards-compatible way of decorating a Java syntax
node with typed metadata which can be used by a preprocessor or other
tool. We define the following annotation type \ttt{Become} in order to
specify state transitions:

\begin{lstlisting}
import java.lang.annotation.*;

@Target({ ElementType.METHOD, ElementType.FIELD })
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent Like a Plaid-style post-state specification \cite{garcia14},
\ttt{Become} allows us to attach annotations of the form
\ttt{@Become(State.class)} to an interface method, where \ttt{State}
is the name of the interface representing the state of the object
after an invocation of the method. The following example illustrates.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class) void init (Channel u);
   }

   interface Shop {
      @Become(Shop.class) Price price (Product p);

      enum Result {
         @Become(Pay.class) OK,
         @Become(Shop.class) ERROR
      }

      @SwitchOn Result buy (Product p);
      @Become(End.class) void stop ();
   }

   interface Pay {
      @Become(Shop.class) void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The top-level \ttt{Buyer} interface is acting as a
namespace here, rather than a state interface.

As the example shows, we also allow \ttt{@Become} annotations to be
attached to fields of an enumeration. Here, the \ttt{@SwitchOn}
annotation on \ttt{buy} indicates that the method transitions to a
state determined by its result type, which must be an enumeration
where every element is annotated with a target state. \ttt{@SwitchOn}
is simply a tag:
\begin{lstlisting}
@Target(ElementType.METHOD)
public @interface SwitchOn {
}
\end{lstlisting}

The implementation class \ttt{BuyerImpl} is essentially as it was
before, except that it must now implement each of the state
interfaces:

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public Result buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\noindent Client code would appear to use the concrete implementation
class directly, but our type system would track the state more
precisely, inferring a more specific interface type for an expression
which would otherwise have that implementation class as its type. (The
implementation class must implement all the methods of all the
interfaces, since we cannot make use of multiple inheritance or
reclassification.) It should be feasible to provide full backwards
compatibility, so that well-typedness in our system implies
well-typedness in Java.

\subsection{Using the annotations for type-checking}

Java Specification Request 269 \cite{jsr269} provides a pluggable
annotation processing API intended for the implementation of
annotation-based language extensions. These facilities can be accessed
via command-line options to \ttt{javac}. It should be possible to
extend \ttt{javac} with an additional pre-processing phase during
which typestate checking would take place. The open source
\emph{Checker} framework \cite{papi08,dietl11} is a comprehensive
example of this approach to extending the Java type system.
