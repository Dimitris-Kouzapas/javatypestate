\documentclass[a4paper]{llncs}
%\documentclass[a4paper]{article}
\usepackage{color}
\usepackage{comment}
\usepackage{xspace}
\usepackage{amsfonts}




\input{macros}

\newcommand{\class}{\ensuremath{\mathtt{class}}\xspace}
\newcommand{\enum}{\ensuremath{\mathtt{enum}}\xspace}
\newcommand{\Null}{\ensuremath{\mathtt{Null}}\xspace}
\newcommand{\nul}{\ensuremath{\mathtt{null}}\xspace}
\newcommand{\this}{\ensuremath{\mathtt{this}}\xspace}
\newcommand{\brk}[1]{\ensuremath{\mathtt{break}}\ #1}
\newcommand{\continue}[1]{\ensuremath{\mathtt{continue}}\ #1}
\newcommand{\return}[1]{\ensuremath{\mathtt{return}}\ #1}
\newcommand{\lab}[1]{\ensuremath{\mathtt{#1:}}\xspace}
\newcommand{\ctype}[2]{#1[#2]}
\newcommand{\base}{\ensuremath{\mathtt{base}}\xspace}
\newcommand{\method}[4]{#1\ #2(#3)\set{#4}}
\newcommand{\vdecl}[2]{#1\ #2}
\newcommand{\mcall}[2]{#1(#2)}
\newcommand{\newo}[1]{\ensuremath{\mathtt{new}\ #1()}}
\newcommand{\switch}[2]{\ensuremath{\mathtt{switch}(#1)\set{#2}}}
\newcommand{\while}[2]{\ensuremath{\mathtt{while}(#1)\set{#2}}}


\newcommand{\init}{\mathsf{init};}

\newcommand{\econtext}[2]{\mathcal{#1}[#2]}

%%%%%%%%%%
%%%%%%%%%%
\title{Formalise Java Typestate}

\author{}

\pagestyle{plain}

%%% 
\begin{document}

	\maketitle


\section{Syntax}
	Syntax:
\[
	\begin{array}{lrcl}
		&D &\bnfis& \class\ C \set{S; \vect{F}; \vect{M}} \bnfbar \enum\ E \set{\vec{l}}\\
		\textrm{(Types)} & T &\bnfis& \Null \bnfbar \ctype{C}{S}\\% \bnfbar \base\\
		\textrm{(Fields)} &F &\bnfis& \vdecl{T}{f}\\		
		\textrm{(Local)} &V &\bnfis& \vdecl{T}{x}\\
		\textrm{(Methods)} &M &\bnfis& \method{T}{m}{T x}{e}\\
		\textrm{(Values)} &v& \bnfis& \nul \bnfbar l\\
		\textrm{(Paths)}  &r& \bnfis & \this \bnfbar \this.f \bnfbar x\\
		\textrm{(Expressions)} &e& \bnfis & V \bnfbar v \bnfbar r \bnfbar r.\mcall{m}{e} \bnfbar e;e \bnfbar r = e\\
		&&\bnfbar & \newo{C} \bnfbar \return{e} \bnfbar \switch{e}{l : e_l}_{l \in E} \\
		&&\bnfbar & \brk{\lambda} \bnfbar \continue \lambda \bnfbar{\lambda}: \while{e_1}{e_2}\\
		&&\bnfbar & \ifthenelse{e}{e}{e}
	\end{array}
\]

	Runtime Syntax:
\[
	\begin{array}{lrcl}
		& T & \bnfis & C[\set{T_i\ f_i}_{i \in I}]\\
		& v & \bnfis & \dots \bnfbar o\\
		& r & \bnfis & o \bnfbar x \bnfbar r.f \\
		\textrm{(Context)} & \mathcal{E} &\bnfis& \hole \bnfbar \mathcal{E}; e \bnfbar r.m(\mathcal{E}) \bnfbar r = \mathcal{E}
				\bnfbar \return{\mathcal{E}}\\
				&&\bnfbar& \switch{\mathcal{E}}{l:e}_{l \in E} \bnfbar \ifthenelse{\mathcal{E}}{e}{e}
	\end{array}
\]

%	Proposal 1:
%
%	\begin{eqnarray*}
%		h \bnfis o = C[\vect{f} = \vec{\nul}] \bnfbar \epsilon\\
%	\end{eqnarray*}
%

%	Proposal 2:
%
	Operational Semantics:
%
	\begin{eqnarray*}
		h &\bnfis& h \cat o = C[\vect{f} = \vec{\nul}] \bnfbar \epsilon\\
		\sigma &\bnfis& \sigma \cat \phi \bnfbar \phi\\
		\phi &\bnfis& \set{\widetilde{x = r}}
	\end{eqnarray*}
%
\[
	\begin{array}{c}
		\tree{
			o\ \textrm{fresh} \quad C.\mathsf{fields} = \vect{f}
		}{
			(h; \sigma; \newo{C}) \red (h \cat o = C[\vect{f} = \vect{\nul}]; \sigma; o)
		}
		\\[6mm]

		\tree{
		}{
			(h; \sigma \cat \phi; \vdecl{T}{x}) \red (h; \sigma \cat \phi \cup \set{x = \nul}; \nul)
		}
		\\[6mm]

		\tree{
			\phi(x) = r \qquad h(r) = v
		}{
			(h; \sigma \cat \phi; x) \red (h \set{r = \nul}; \sigma \cat \phi; v)
		}
		\\[6mm]

%		\tree{
%			h(o) = v
%		}{
%			(h; \sigma; o) \red (h \set{o = \nul}; \sigma; v)
%		}\\[6mm]

		\tree{
			r \not= x \qquad h(r) = v
		}{
			(h; \sigma; r) \red (h \set{r = \nul}; \sigma; v)
		}\\[6mm]

		\tree {
			r \not= x
		}{
			(h;\sigma; r = v) \red (h\set{r = v};\sigma; \nul)
		}\\[6mm]

		\tree {
			\phi(x) = r
		}{
			(h;\sigma \cat \phi; x = v) \red (h\set{r = v};\sigma \cat \phi; \nul)
		}\\[6mm]


		\tree {
			\method{T_1}{m}{T_2 x}{e} \in h(r).\class 
		}{
			(h;\sigma;r.m(v)) \red (h; \sigma \cat \es; e \subst{r}{\this} \subst{v}{x})
		}\\[6mm]

		\tree{}{(h; \sigma; v; e) \red (h; \sigma; e)}
		\\[6mm]

		\tree{
			(h; \sigma; e) \red (h'; \sigma'; e')
		}{
			(h; \sigma; \econtext{E}{e}) \red (h'; \sigma'; \econtext{E}{e'})
		}
		\\[6mm]

		\tree{}{(h;\sigma \cat \phi; \return{v}) \red (h;\sigma;v)}
		\\[6mm]

		\tree{
			l_k \in E
		}{
			(h;\sigma;\switch{l_k}{l: e_l}_{l \in E}) \red (h;\sigma; e_{l_k})
		}\\[6mm]

		\tree{
		}{
			(h; \sigma; \ifthenelse{\true}{e_1}{e_2}) \red (h; \sigma; e_1)
		}
		\\[6mm]

		\tree{
		}{
			(h; \sigma; \ifthenelse{\false}{e_1}{e_2}) \red (h; \sigma; e_2)
		}
		\\[6mm]

		\tree{
		}{
			(h; \sigma; \lambda: \while{e_1}{e_2}) \red (h; \sigma; \ifthenelse{e_1}{e_2 ;\lambda: \while{e_1}{e_2}}{\false})
		}
		\\[6mm]

	\end{array}
\]

\section{Typing}

\begin{eqnarray*}
	\Gamma &\bnfis& r: C[\set{S_i}]_{i \in I} \cat \Gamma \bnfbar \es\\
	\Delta &\bnfis& r: T \cat \Delta \bnfis \es 
\end{eqnarray*}

\[
	\begin{array}{c}
		\tree {
			\Gamma(x) = C[\set{S_i}]_{i \in I} 
		}{
			\Gamma; \Delta \proves C[S]\ x: C[\tinact] \dashv \Gamma; \Delta \cat x: C[\tinact]
		}\ \trule{Scope}
		\\[6mm]

		\tree {
		}{
			\Gamma; \Delta \proves \nul : \Null \dashv \Gamma;\Delta
		}\ \trule{Null}
		\\[6mm]

		\tree {
			\dk{l \in E}
		}{
			\Gamma; \Delta \proves l : E \dashv \Gamma; \Delta
		}\ \trule{Enum}
		\\[6mm]

		\tree {
		}{
			\Gamma; \Delta \cat r: \tinact \proves r: T \dashv \Gamma; \Delta \cat r: T
		}\ \trule{Path}
		\\[6mm]

		\tree {
			\Gamma; \Delta r: T \proves e: T' \dashv \Gamma''; \Delta'' \cat r: C[m(T_x\ x); S] \qquad
			\method{T_m}{m}{T_x\ x}{e'} \in C.\class
			\qquad
			\dk{\textrm{stack frame}}
		}{
			\Gamma; \Delta \cat r: T \proves r.m(e): T \dashv \Gamma'; \Delta' \cat r: C[S]
		}\ \trule{Call}
		\\[6mm]

		\tree {
			\Gamma; \Delta \proves e_1 \dashv \Gamma''; \Delta'' \qquad
			\Gamma''; \Delta'' \proves e_2 \dashv \Gamma'; \Delta'
		}{
			\Gamma; \Delta \proves e_1; e_2: T \dashv \Gamma'; \Delta'
		}\ \trule{Seq}
		\\[6mm]

		\tree {
			\Gamma \cat r: C[\set{S}_{i \in I}]; \Delta \cat r: C[S] \proves e: C[S] \dashv \Gamma' \cat r: C[\set{S}_{i \in I}]; \Delta' \cat r: C[S']
		}{
			\Gamma \cat r: C[\set{S}_{i \in I} \cup \set{S}]; \Delta \cat r: C[\tinact] \proves r = e : C[\tinact] \dashv \Gamma' \cat r: C[\set{S}_{i \in I}]; \Delta' \cat r: C[S']
		}\ \trule{Assign}
		\\[6mm]

		\tree {
			\dk{o ???} \qquad \dk{\textrm{o should be assignable}}
		}{
			\Gamma; \Delta \cat o: C[\init S] \proves \newo{C} : C[\init S] \dashv \Gamma; \Delta \cat o: C[S]
		}\ \trule{New}
		\\[6mm]


		\tree {
			\Gamma; \Delta \proves e \dashv \Gamma'; \Delta' \qquad \dk{\textrm{stack frame}}
		}{
			\Gamma; \Delta \cat \tilde{x}: \tilde{T} \proves \return{e} \dashv \Gamma'; \Delta'
		}\ \trule{Return}
		\\[6mm]

		\tree {
			\begin{array}{l}
				\Gamma; \Delta \cat r : T \proves r.m(e) : E \dashv \Gamma''; \Delta'' \cat r: C[\lrangle{S_l}_{i \in E}] \\
				\forall l \in E, \Gamma''; \Delta'' \cat r: C[S_l] \proves e_l: C[S_l] \dashv \Gamma'; \Delta' \cat r: C[S]
			\end{array}
		}{
			\Gamma; \Delta \cat r: T \proves \switch{r.m(e)}{l: e_l}_{l \in E} \dashv \Gamma'; \Delta \cat r: C[S]
		}
		\\[6mm]

		\tree {
			\begin{array}{l}
				\Gamma_1; \Delta_1 \proves e_1 \dashv \Gamma'; \Delta'
				\qquad 
				\Gamma_2; \Delta_2 \proves e_1;e_2 \dashv \Gamma''; \Delta''
				\\
				r: C[\set{S_1, S_2}] \in \Delta \textrm{ if } r: C[S_1] \in \Delta_2 \wedge r: C[S_2] \in \Delta_2
				\\
				\Gamma = \dk{\Gamma' \cup \Gamma''}
			\end{array}
		}{
			\Gamma; \Delta \cat r: T \proves \lambda: \while{e_1}{e_2} \dashv \Gamma'; \Delta'
		}
	\end{array}
\]


%



%	Proposal 3:
%
%	\begin{eqnarray*}
%		\iota &\in& \mathbb{N}\\% \cup \set{0}\\
%		h &\bnfis& h \cat \iota: C[\widetilde{f \mapsto 0}] \bnfbar 0: \nul \\%\epsilon\\
%		\sigma &\bnfis& \sigma \cat \phi \bnfbar \phi\\
%		\phi &\bnfis& \set{\widetilde{o \mapsto \iota}}
%	\end{eqnarray*}
\end{document}
%%%
