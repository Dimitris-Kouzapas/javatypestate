\section{Typestate for Java via interfaces and annotations}

The first typestate language such as Plural \cite{bierhoff11} used
pre- and post-condition annotations on methods to specify state
transitions. More recent languages such as Plaid \cite{garcia14} unify
states with classes; in these ``typestate-oriented'' languages, state
change is object reclassification. Our current approach is different
from both of these: we introduce a separate typestate definition. This
may have merits, but it also has a significant cost in requiring
method and type signatures to be duplicated in similar (but not
identical) notations. Both the user, and the language design itself,
are forced to consider the interaction between typestate declarations
and similar Java definitions. For example:

\begin{itemize}
\item Overloading. What if I define two methods called \ttt{buy}?
\item Mismatches between typestate definitions and Java definitions
\item Extending typestate with new features, e.g.~inheritance or
  exceptions
\item Integration with IDE features like refactoring
\end{itemize}

\noindent An alternative approach based on annotations, which
side-steps many of these problems by integrating more directly with
Java, is outlined below.

\subsection{Typestates as interfaces}

An interface specifies the methods available on an object. Since this
is what a typestate also does, a natural question is: can a typestate
be captured as an interface where each method is annotated with a
specification of the resulting state? In such an approach, tracking
the state of an object statically is like implicitly casting it
between the various state interfaces; the underlying implementation
class has to implement all the methods and all the interfaces. (There
is no multiple inheritance or reclassification in Java, which is why
we propose interfaces rather than classes.)

First we use a so-called \emph{annotation type} to define a new kind
of Java annotation called \ttt{Target}:

\begin{lstlisting}
import java.lang.annotation.*;

@Target(ElementType.METHOD)
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent \ttt{Target} allows us to attached annotations of the form
\ttt{@Become(State.class)} to a method, specifying \ttt{State} as the
name of the interface representing the typestate of the object after
the method invocation. We can use these annotations to decorate the
interface methods, in a backwards-compatible way, with Plaid-style
transition specifications \cite{garcia14}, as shown in the following
example. The \ttt{@ResultCase} construct is explained below.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class)
      void init (Channel u);
   }

   interface Shop {
       @Become(Shop.class)
       Price price (Product p);

       @ResultCase(is = Result.OK, then = @Become(Pay.class))
       @ResultCase(is = Result.ERROR, then = @Become(Shop.class))
       void buy (Product p);

       @Become(End.class)
       void stop ();
   }

   interface Pay {
       @Become(Shop.class)
       void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The top-level \ttt{Buyer} interface is acting as a
namespace, rather than a state interface. A \ttt{@ResultCase} is used
to map a returned enumeration value to a state. (Duplicate annotations
like this are legal in Java 8.) However, because annotation types
can't make use of generics, the user would have to manually define an
appropriate \ttt{@ResultCase} class of the following form:
\begin{lstlisting}
@interface ResultCase {
   Result is ();
   Become then ();
}
\end{lstlisting}

\noindent However there are probably other encoding schemes which
avoid this particular shortcoming.

The implementation class \ttt{BuyerImpl} is essentially as it was
before, except that it must now implement each of the state
interfaces:

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public void buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\subsection{Using the annotations for type-checking}

Finally, we consider how such an annotation-based language extension
could be implemented. Java Specification Request (JSR) 269
\cite{jsr269} adds a pluggable annotation processing API to Java to
allow tools to process annotations; \ttt{javac} provides access to
these facilities via command-line options. These can be used to extend
\ttt{javac} with an additional phase where typestate checking takes
place. The open source \emph{Checker} framework \cite{papi08,dietl11}
is a comprehensive example of the use of annotations to extend Java's
type system in this way.
