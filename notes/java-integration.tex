\section{Typestate definitions}

Early typestate language such as Plural \cite{bierhoff11} used pre-
and post-condition annotations on methods to specify state
transitions. More recent languages such as Plaid \cite{garcia14} unify
states with classes; in these ``typestate-oriented'' languages, state
change is object reclassification.

We currently take a third approach, namely of introducing a separate
typestate definition. This may have merits, but it also has a
significant cost, namely the duplication of method and type
signatures. Both the user, and our implementation, is forced to
consider the interaction between typestate declarations and other Java
language features. For example:

\begin{itemize}
\item Overloading. What if I define two methods called \ttt{buy}?
\item Mismatches between typestate definitions and Java definitions.
\item Extending typestate with new features, e.g.~inheritance or
  exceptions.
\item Integration with IDE features like refactoring.
\end{itemize}

\noindent An alternative approach based on annotations is outlined
below.

\subsection{Representing typestates using interfaces and annotations}

An interface specifies the methods available on an object. A typestate
also does this, so a natural question is: is a typestate an interface,
annotated with additional information specifying the target state of
each method? Tracking the state of an object statically is like
implicitly casting it to a new interface, and so the underlying object
has to implement all the methods and all the interfaces. (In Java a
class is either \ttt{Object} or has exactly one immediate superclass.)

First we use a so-called \emph{annotation type} to define a new kind
of Java annotation called \ttt{Target}:

\begin{lstlisting}
import java.lang.annotation.*;

@Target(ElementType.METHOD)
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent This would allow us to write \ttt{@Become(State.class)} as
an annotation on a method, where \ttt{State} is the name of a state
interface. We can use these to decorate the interface methods with the
target state; essentially this is a backwards-compatible way of
extending the syntax of Java to allow Plaid-style transition
declarations \cite{garcia14}. The following example illustrates; the
\ttt{@ResultCase} construct is explained below.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class)
      void init (Channel u);
   }

   interface Shop {
       @Become(Shop.class)
       Price price (Product p);

       @ResultCase(is = Result.OK, then = @Become(Pay.class))
       @ResultCase(is = Result.ERROR, then = @Become(Shop.class))
       void buy (Product p);

       @Become(End.class)
       void stop ();
   }

   interface Pay {
       @Become(Shop.class)
       void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The implementation is essentially as it was before, except
that the class \ttt{BuyerImpl} must implement each of the state
interfaces. The job of the typestate extensions to the compiler is to
allow the user to call methods on the state interfaces without having
to explicitly cast. Java Specification Request (JSR) 269 \cite{jsr269}
adds a pluggable annotation processing API to Java to allow the
authoring of tools that process annotations; these facilities can be
accessed via command-line options to \ttt{javac}. The open source
Checker framework \cite{papi08,dietl11} is a comprehensive example of
the use of annotations to extend Java's type system.

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public void buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\noindent The duplicate annotations like this are legal in Java 8.
Because annotation types can't make use of generics, the user would
also have to define
\begin{lstlisting}
@interface ResultCase {
   Result is ();
   Become then ();
}
\end{lstlisting}
