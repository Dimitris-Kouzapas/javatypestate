\section{Typestate definitions and interfaces.}

Early typestate language such as Plural \cite{bierhoff11} used pre-
and post-condition annotations on methods to specify state
transitions. More recent languages such as Plaid \cite{garcia14} unify
states with classes; in these ``typestate-oriented'' languages, state
change is object reclassification (avoiding the issue with multiple
inheritance).

We currently take a third approach, namely of introducing a separate
typestate definition. This may have merits, but it clearly has a
significant cost, namely the duplication of method and type
signatures. How it interacts with overloading is unclear (what if I
define two methods called \ttt{buy}?), as is what happens if there is
a mismatch between the typestate definition and the class definition
(say . The advantages/disadvantages of the approach need to be weighed
in the light of what we're trying to achieve.

\subsection{Relationship to interfaces}

(A Java class cannot have two unrelated superclasses, so let's
restrict the discussion to interfaces.) An interface specifies the
methods available on an object. A typestate also does this, so a
natural question is: is a typestate an interface, annotated with
information about target states? Tracking the state of an object
statically is like implicitly casting it to a new interface; the
underlying object has to implement all the methods and all the
interfaces.

First we use a so-called \emph{annotation type} to define a new kind
of Java annotation called \ttt{Target}:

\begin{lstlisting}
import java.lang.annotation.*;

@Target(ElementType.METHOD)
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent This would allow us to write \ttt{@Become(State.class)} as
an annotation on a method, where \ttt{State} is the name of a state
interface. We can use these to decorate the interface methods with the
target state; think of this as a backwards-compatible way of extending
the syntax of Java to allow Plaid-style transition declarations
\cite{garcia14}.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class)
      void init (Channel u);
   }

   interface Shop {
       @Become(Shop.class)
       Price price (Product p);

       @ResultCase(is = Result.OK, then = @Become(Pay.class))
       @ResultCase(is = Result.ERROR, then = @Become(Shop.class))
       void buy (Product p);

       @Become(End.class)
       void stop ();
   }

   interface Pay {
       @Become(Shop.class)
       void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The implementation is essentially as it was before, except
that the class \ttt{BuyerImpl} must implement each of the state
interfaces. The job of the typestate extensions to the compiler is to
allow the user to call methods on the state interfaces without having
to explicitly cast.

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public void buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\noindent \ttt{Channel} would also be modelled as a class with its own
typestate interfaces.

\noindent The duplicate annotations like this are legal in Java 8.
Because annotation types can't make use of generics, the user would
also have to define
\begin{lstlisting}
@interface ResultCase {
   Result is ();
   Become then ();
}
\end{lstlisting}
