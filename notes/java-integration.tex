\section{Typestate for Java via interfaces and annotations}

The first typestate experiments such as Plural \cite{bierhoff11} used
pre- and post-condition annotations on methods to specify state
transitions. More recent efforts such as Plaid \cite{garcia14} unify
states with classes; in these ``typestate-oriented'' languages, state
change is object reclassification. Our current approach is different
again, utilising a separate typestate definition. This may have
merits, but it also has a significant cost in requiring method and
type signatures to be duplicated, using similar (but not identical)
notations. Both the user, and the language design itself, are forced
to consider the interaction between typestate declarations and the
corresponding Java definitions. For example:

\begin{itemize}
\item Overloading. What if I define two methods called \ttt{buy}?
\item Mismatches between typestate definitions and Java definitions
\item Extending typestate with new features, e.g.~inheritance or
  exceptions
\item Integration with IDE features like refactoring
\end{itemize}

\noindent An alternative approach based on annotations, which
side-steps many of these problems by integrating more directly with
Java, is outlined below.

\subsection{Typestates as interfaces}

An interface specifies the methods available on an object. Since this
is what a typestate also does, a natural question is: can a typestate
be captured as an interface where each method is annotated with a
specification of the resulting state? In such an approach, tracking
the state of an object statically is like implicitly casting it
between the various state interfaces. The underlying implementation
class must implement all the methods of all the interfaces. (There is
no multiple inheritance or reclassification in Java, which is why we
propose interfaces rather than classes.)

First we use a so-called \emph{annotation type} to define a new kind
of Java annotation called \ttt{Target}:

\begin{lstlisting}
import java.lang.annotation.*;

@Target({ ElementType.METHOD, ElementType.FIELD })
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent \ttt{Target} allows us to attached annotations of the form
\ttt{@Become(State.class)} to a method, specifying \ttt{State} as the
name of the interface representing the typestate of the object after
the method invocation. We can use these annotations to decorate
interface methods, in a backwards-compatible way, with Plaid-style
transition specifications \cite{garcia14}, as shown in the following
example. We also allow \ttt{@Target} definitions to be attached to
fields of an enumeration; this is explained below.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class) void init (Channel u);
   }

   interface Shop {
      @Become(Shop.class) Price price (Product p);

      enum Result {
         @Become(Pay.class) OK,
         @Become(Shop.class) ERROR
      }

      @SwitchOn Result buy (Product p);
      @Become(End.class) void stop ();
   }

   interface Pay {
      @Become(Shop.class) void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The top-level \ttt{Buyer} interface is acting as a
namespace here, rather than a state interface.

The \ttt{@SwitchOn} annotation on \ttt{buy} indicates that this method
transitions to a state determined by its result type, which (as it is
here) must be an enumeration where every field is annotated with a
target state. However, because annotation types can't make use of
generics, the user would have to manually define an appropriate
\ttt{@ResultCase} class of the following form:
\begin{lstlisting}
@interface ResultCase {
   Result is ();
   Become then ();
}
\end{lstlisting}

\noindent However there are probably other encoding schemes which
avoid this particular shortcoming.

The implementation class \ttt{BuyerImpl} is essentially as it was
before, except that it must now implement each of the state
interfaces:

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public void buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\subsection{Using the annotations for type-checking}

Finally, we consider how such an annotation-based language extension
could be implemented. Java Specification Request (JSR) 269
\cite{jsr269} adds a pluggable annotation processing API to Java to
allow tools to process annotations; \ttt{javac} provides access to
these facilities via command-line options. These can be used to extend
\ttt{javac} with an additional phase where typestate checking takes
place. The open source \emph{Checker} framework \cite{papi08,dietl11}
is a comprehensive example of the use of annotations to extend Java's
type system in this way.
