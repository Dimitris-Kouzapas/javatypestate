\section{Typestates as annotated interfaces}

The first typestate experiments such as Plural \cite{bierhoff11} used
pre- and post-condition annotations on methods to specify state
transitions. More recent efforts such as Plaid \cite{garcia14} unify
states with classes; in these ``typestate-oriented'' languages, state
change is achieved via object reclassification.

Our current approach is similar to the first approach but utilises a
separate typestate definition. Merits aside, a distinct notion of
typestate definition introduces unneeded complexity into the
programming model and the language design: both the user, and our
compiler, are forced to consider the interaction between typestate
definitions and the Java definitions they relate to. For example, we
must resolve language definition and tooling issues like the
following:

\begin{itemize}
\item Can I overload typestate methods (e.g. two methods
  called \ttt{buy})?
\item When is a Java definition is deemed to ``match'' a typestate
  definition?
\item How to extend typestate with features like inheritance or exceptions?
\item Can I use a typestate definition as an interface or vice versa?
\end{itemize}

\noindent An alternative strategy would be to utilise and extend
Java's existing notions of interface and method signature. That way we
can leverage the rules Java already uses to answer such questions. An
additional advantage is that IDE features like refactoring that work
with specific language features will have some chance of working with
our proposed extensions. One way to extend Java in a
backwards-compatible way is to use \emph{annotations}; such an
approach is outlined below.

\subsection{Typestate via annotations}

An interface specifies the methods available on an object. Since this
is what a typestate also does, our strategy will be to represent a
typestate as an interface where each method is \emph{annotated} with a
specification of the state that it transitions the object to. An
annotation is a backwards-compatible way of decorating Java syntax
nodes with additional metadata which can be used by preprocessors or
other tools.

Tracking the state of tan object would amount to inferring a more
specific interface type for an expression whose standard Java type is
a concrete implementation class. The implementation class must
implement all the methods of all the interfaces, to ensure that there
are no runtime errors associated with changes in static type. (There
is no multiple inheritance or reclassification in Java.) It should be
possible to provide full backwards compatibility, so that
well-typedness in our system implies well-typedness in Java.

Annotations are typed metadata and their types are given by so-called
\emph{annotation types}. The following annotation type \ttt{Become} is
used to specify state transitions:

\begin{lstlisting}
import java.lang.annotation.*;

@Target({ ElementType.METHOD, ElementType.FIELD })
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent \ttt{Become} allows us to attach annotations of the form
\ttt{@Become(State.class)} to a method, where \ttt{State} is the name
of the interface representing the typestate of the object after the
method invocation. We can use these annotations to decorate interface
methods, in a backwards-compatible way, with Plaid-style transition
specifications \cite{garcia14}, as shown in the following example. We
also allow \ttt{@Become} definitions to be attached to fields of an
enumeration; this is explained below.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class) void init (Channel u);
   }

   interface Shop {
      @Become(Shop.class) Price price (Product p);

      enum Result {
         @Become(Pay.class) OK,
         @Become(Shop.class) ERROR
      }

      @SwitchOn Result buy (Product p);
      @Become(End.class) void stop ();
   }

   interface Pay {
      @Become(Shop.class) void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The top-level \ttt{Buyer} interface is acting as a
namespace here, rather than a state interface.

The \ttt{@SwitchOn} annotation on \ttt{buy} indicates that this method
transitions to a state determined by its result type, which (as here)
must be an enumeration where every element is annotated with a target
state. \ttt{@SwitchOn} is simply a tag:
\begin{lstlisting}
@Target(ElementType.METHOD)
public @interface SwitchOn {
}
\end{lstlisting}

The implementation class \ttt{BuyerImpl} is essentially as it was
before, except that it must now implement each of the state
interfaces:

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public Result buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

\subsection{Using the annotations for type-checking}

Here is how such an annotation-based language extension could be
implemented. Java Specification Request (JSR) 269 \cite{jsr269} adds a
pluggable annotation processing API to Java to allow tools to process
annotations; \ttt{javac} provides access to these facilities via
command-line options. These could be used to extend \ttt{javac} with
an additional pre-processing phase during which typestate checking
would take place. The open source \emph{Checker} framework
\cite{papi08,dietl11} is a comprehensive example of the use of
annotations to define Java type system extensions.
