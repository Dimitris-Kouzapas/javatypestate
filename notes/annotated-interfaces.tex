\section{Typestates as annotated interfaces}

The first typestate experiments such as Plural \cite{bierhoff11} used
pre- and post-condition annotations on methods to specify state
transitions. More recent ``typestate-oriented'' efforts such as Plaid
\cite{garcia14} unify states with classes. In such a language state
change amounts to object reclassification.

Our current approach is similar to the first approach but utilises a
separate typestate definition. Merits aside, a distinct notion of
typestate definition introduces unneeded complexity into the
programming model and language design: both the user, and our
compiler, are forced to consider the interaction between typestate
definitions and the Java definitions they relate to. For example, we
must resolve language definition issues like the following:

\begin{itemize}
\item Can I overload typestate methods (e.g. have two methods called
  \ttt{buy})?
\item When is a Java definition is deemed to ``match'' a typestate
  definition?
\item How to extend typestate with features like inheritance or exceptions?
\item Can I use a typestate definition as an interface or vice versa?
\end{itemize}

\noindent A more practical strategy would be to utilise and extend
Java's existing notions of interface and method signature, leveraging
the rules Java already uses to answer such questions. An additional
advantage is that IDE features like refactoring that work with
specific language features will have some chance of working with our
proposed extensions. One way to extend Java in a backwards-compatible
way is to use \emph{annotations}; such an approach is outlined below.

\subsection{Typestate via annotations}

An interface specifies the methods available on an object. Since this
is what a typestate also does, our strategy will be to represent a
typestate as an interface where each method is \emph{annotated} with a
specification of the state that it transitions the object to. An
annotation is a backwards-compatible way of decorating Java syntax
nodes with typed metadata which can be used by preprocessors or other
tools. The following annotation type \ttt{Become} is used to specify
state transitions:

\begin{lstlisting}
import java.lang.annotation.*;

@Target({ ElementType.METHOD, ElementType.FIELD })
public @interface Become {
   Class<? extends Object> value ();
}
\end{lstlisting}

\noindent \ttt{Become} allows us to attach annotations of the form
\ttt{@Become(State.class)} to a method, where \ttt{State} is the name
of the interface representing the typestate of the object after the
method invocation. We can use these annotations to decorate interface
methods, in a backwards-compatible way, with Plaid-style transition
specifications \cite{garcia14}, as shown in the following example. We
also allow \ttt{@Become} definitions to be attached to fields of an
enumeration; this is explained below.

\begin{lstlisting}
public interface Buyer {
   interface Init {
      @Become(Shop.class) void init (Channel u);
   }

   interface Shop {
      @Become(Shop.class) Price price (Product p);

      enum Result {
         @Become(Pay.class) OK,
         @Become(Shop.class) ERROR
      }

      @SwitchOn Result buy (Product p);
      @Become(End.class) void stop ();
   }

   interface Pay {
      @Become(Shop.class) void pay (Payment p);
   }
}
\end{lstlisting}

\noindent The top-level \ttt{Buyer} interface is acting as a
namespace here, rather than a state interface.

The \ttt{@SwitchOn} annotation on \ttt{buy} indicates that this method
transitions to a state determined by its result type, which (as here)
must be an enumeration where every element is annotated with a target
state. \ttt{@SwitchOn} is simply a tag:
\begin{lstlisting}
@Target(ElementType.METHOD)
public @interface SwitchOn {
}
\end{lstlisting}

The implementation class \ttt{BuyerImpl} is essentially as it was
before, except that it must now implement each of the state
interfaces:

\begin{lstlisting}
class BuyerImpl implements Buyer.Init, Buyer.Shop, Buyer.Pay {
   public void init (Channel u) { ... }
   public void pay(Payment p) { ... }
   public Price price (Product p) { ... }
   public Result buy (Product p) { ... }
   public void stop() { ... }
}
\end{lstlisting}

Client code would appear to use the concrete implementation class
directly, but our type system would track the state of an object,
inferring a more specific interface type for an expression whose
standard Java type is the implementation class. The implementation
class must implement all the methods of all the interfaces, since
there is no multiple inheritance or reclassification in Java. It
should be possible to provide full backwards compatibility, so that
well-typedness in our system implies well-typedness in Java.

\subsection{Using the annotations for type-checking}

Here is how such an annotation-based language extension could be
implemented. Java Specification Request (JSR) 269 \cite{jsr269} adds a
pluggable annotation processing API to Java to allow tools to process
annotations; \ttt{javac} provides access to these facilities via
command-line options. These could be used to extend \ttt{javac} with
an additional pre-processing phase during which typestate checking
would take place. The open source \emph{Checker} framework
\cite{papi08,dietl11} is a comprehensive example of the use of
annotations to define Java type system extensions.
