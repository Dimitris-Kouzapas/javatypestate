aspect getGraph {

	//Attributes for handling recursion using break, continue and labels

	inh Stmt ContinueStmt.getTargetStmt(String label);
	inh Stmt BreakStmt.getTargetStmt(String label);
	inh Stmt LabeledStmt.getTargetStmt(String label);

	eq LabeledStmt.getStmt().getTargetStmt(String label) = getLabel().equals(label) ? this : getTargetStmt(label);

	inh Stmt ContinueStmt.getTargetStmt();
	inh Stmt BreakStmt.getTargetStmt();
	eq WhileStmt.getStmt().getTargetStmt() = this;
	eq ForStmt.getStmt().getTargetStmt() = this;
	eq DoStmt.getStmt().getTargetStmt() = this;
	eq SwitchStmt.getBlock().getTargetStmt() = this;

	eq TypeDecl.getBodyDecl(int i).getTargetStmt(String label) = null;
	eq TypeDecl.getBodyDecl(int i).getTargetStmt() = null;

/*****************************************************************************************************/
	//TODO implement
	syn lazy TypestateVar Expr.getTypestateVar();

	//Not used
	eq AmbiguousAccess.getTypestateVar() = null;
	eq VarAccess.getTypestateVar() = null;
	eq SuperAccess.getTypestateVar() = null;
	eq PackageOrTypeAccess.getTypestateVar() = null;
	eq PackageAccess.getTypestateVar() = null;

	eq Binary.getTypestateVar() = null;				//Binary results in PrimitiveType
	eq Unary.getTypestateVar() = null;				//Unary results in PrimitiveTypes
	eq Literal.getTypestateVar() = null;				//Literals are also non typestate
	eq InstanceOfExpr.getTypestateVar() = null;			//Boolean type
	eq ClassInstanceExpr.getTypestateVar() = null;			//ClassInstanceoOfExpr should give null
	eq CastExpr.getTypestateVar() = getExpr().getTypestateVar();	//expect CastExpr not to have typestate type
	eq ArrayInit.getTypestateVar() = null;				//Typestate types are not arrays
	eq ArrayCreationExpr.getTypestateVar() = null;			//Typestate types are not arrays
	eq ParExpr.getTypestateVar() = getExpr().getTypestateVar();
	eq AssignExpr.getTypestateVar() = getDest().getTypestateVar();	//TODO is this ok?

	eq ConditionalExpr.getTypestateVar() = null;			//TODO This is actually a problem... Maybe need to be dealt
									//TODO as a case when assignment takes place.

	eq ConstructorAccess.getTypestateVar() = null;
	eq TypeAccess.getTypestateVar() = null;				//Expected to be null
	eq ClassAccess.getTypestateVar() = null;

	eq AbstractDot.getTypestateVar() = getRight().getTypestateVar();

	eq ThisAccess.getTypestateVar() {
		if(isAbstractDotParent())				//Qualified "this" is not supposed to be used as a right child of the Dot
									//because we do not have internal classes
			return null;
		return null;						//TODO the case with code like Obj o = this; ??. Avoid this case ??
	}

	eq ArrayAccess.getTypestateVar() = null;			//Typestate types are not arrays
	eq MethodAccess.getTypestateVar() = getType().isTypestateClassDeclType() ?  typestate : null; //TODO is that it??

	eq ParseName.getTypestateVar() {
		if(!getType().isTypestateClassDeclType())
			return null;
		if(getQualifiedAccess() != null)
			return lookupVariable(getQualifiedType()).getTypestateVar();
		return lookupVariable().getTypestateVar();
	}

	syn lazy TypestateVar Access.getQualifiedTypestateVar() =
		getQualifiedAccess() != null ? 
		getQualifiedAccess().getLeft().getTypestateVar() :
		null;							//TODO this means that the caller object is this


/*****************************************************************************************************/

	syn lazy boolean MethodAccess.isThisAccess() {
		if(getQualifiedAccess() == null)
			return true;

		//TODO find a way for no instanceof
		if(getQualifiedAccess().getLeft() instanceof ThisAccess)
			return true;

		return false;
	}

/*****************************************************************************************************/

	syn Set<VariableDecl> ClassDecl.getTypestateFields() {
		Set<VariableDecl> s = new HashSet<VariableDecl>();
		for(VariableDecl vd: getFieldDecls())
			if(vd.getTypeAccess().lookupType().isTypestateClassDeclType())
				s.add(vd);
		return s;
	} 


	syn lazy boolean ClassDecl.getGraph() {
		for(MethodDecl md: getMethodDecls())
			md.getGraph();

		if(isTypestateClassDeclType()) {
			TypestateClassDecl cd = (TypestateClassDecl) this;
			if(cd.existsTypestateDecl()) {
				GraphNode r = null;
				r = cd.getTypestateDecl().createTypestate().normalise();
				for(VariableDecl vd: getTypestateFields()) {
					vd.typestate.current = new EndNode();
					cd.getFieldGraph(r, vd, new HashMap<GraphNode, GraphNode>());
					vd.typestate.checkError(vd);
				}
			}
		}

		return true;
	}

	syn GraphNode ClassDecl.getFieldGraph(GraphNode r, VariableDecl vd, Map<GraphNode, GraphNode> visited) {
		if(visited.get(r) != null)
			return visited.get(r);

		LoopNode s = new LoopNode();
		visited.put(r, s);

		LoopNode l = new LoopNode();

		GraphNode t = vd.typestate.current;

		for(GraphNode n : r.next) {
			vd.typestate.current = t;
			getFieldGraph(n, vd, visited);
			l.addNext(vd.typestate.current);
		}

		if(r.next.size() > 0)
			vd.typestate.current = l;

		MethodDecl md = null;
		if(r.getId() != null && r.getParameters() != null)
			md = lookupMethod(r.getId(), r.getParameters());

		//if md == null then r is the Switch/Init/End Node
		if(md != null)
			vd.typestate.getMethodGraph(md);

		vd.typestate.current = s.addNext(vd.typestate.current);
		

		return vd.typestate.current;
	}


/*****************************************************************************************************/

	syn Set<VariableDecl> MethodDecl.getTypestateFields() = getClassDeclAncestor().getTypestateFields();

	private boolean MethodDecl.isGraph = false;
	protected boolean MethodDecl.isGraph() {return isGraph;}
	syn lazy boolean MethodDecl.getGraph() {
		//if(isGraph == true)
		//	return true;
		isGraph = true;

		Set<TypestateVar> env = new HashSet<TypestateVar>();

		for(VariableDecl vd : getTypestateFields()) {
			if(vd.typestate == null)
				vd.typestate = new TypestateField();
			env.add(vd.typestate);
		}

		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).getTypeAccess().lookupType().isTypestateClassDeclType())
				env.add(getParameter(i).typestate = new TypestatePar());

		getBlock().getGraph(env);

		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).getTypeAccess().lookupType().isTypestateClassDeclType()) {
				getParameter(i).typestate.addConnectionTypestate(null);
				env.remove(getParameter(i).typestate);
			}

		for(TypestateVar tv : env) {
			tv.addConnectionTypestate(this);
			env.remove(tv);
		}

		return true;
	}

	syn GraphNode MethodDecl.getParameterTypestate(int i) {
		if(isGraph == false)
			getGraph();
		return getParameter(i).typestate.getConnectionTypestate();
	}

/*****************************************************************************************************/

	//Note: the next case of code is not a valid java statement
	//	if(cond)
	//		TypestateVariable v = new TypestateVariable().m1().m2().m3();	

	protected TypestateVar VariableDecl.typestate = null;
	protected TypestateVar ParameterDeclaration.typestate = null;
	protected TypestateVar MethodAccess.typestate = new TypestateAccess();			//TODO if is  typestate

	syn boolean Stmt.getGraph(Set<TypestateVar> env);

	eq Block.getGraph(Set<TypestateVar> env) {
		for(VariableDecl v: getVariableDecls())
			if(v.getTypeAccess().lookupType().isTypestateClassDeclType())
				env.add(v.typestate = new TypestateVar());

		for(int i = getNumStmt() - 1; i >= 0; i--)
			getStmt(i).getGraph(env);

		for(VariableDecl v: getVariableDecls())
			if(v.getTypeAccess().lookupType().isTypestateClassDeclType()) {
				v.typestate.checkError(v);
				env.remove(v.typestate);
			}
		return true;
	}

	//Not used stmts
	eq VariableDeclaration.getGraph(Set<TypestateVar> env) = false;
	eq SynchronizedStmt.getGraph(Set<TypestateVar> env) = false;
	eq LocalClassDeclStmt.getGraph(Set<TypestateVar> env) = false;

	//No typestate stmts
	eq ConstCase.getGraph(Set<TypestateVar> env) = true;
	eq DefaultCase.getGraph(Set<TypestateVar> env) = true;
	eq EmptyStmt.getGraph(Set<TypestateVar> env) = true;

	//TODO try and throw
	eq TryStmt.getGraph(Set<TypestateVar> env) = true;
	eq ThrowStmt.getGraph(Set<TypestateVar> env) = true;

	eq AssertStmt.getGraph(Set<TypestateVar> env) = getfirst().getGraph(env);
	eq ExprStmt.getGraph(Set<TypestateVar> env) = getExpr().getGraph(env);

	eq LabeledStmt.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v : env) {
			v.start.put(this, new LoopNode());
			v.end.put(this, v.current);
		}
		getStmt().getGraph(env);
		for(TypestateVar v: env) {
			GraphNode n = v.start.remove(this);
			v.current = n.addNext(v.current);
			v.end.remove(this);
		}

		return true;
	}

	eq ContinueStmt.getGraph(Set<TypestateVar> env) {
		Stmt target = getLabel().equals("") ? getTargetStmt() : getTargetStmt(getLabel());
		for(TypestateVar v: env)
			v.current = v.start.get(target);

		return true;
	}

	eq BreakStmt.getGraph(Set<TypestateVar> env) {
		Stmt target = getLabel().equals("") ? getTargetStmt() : getTargetStmt(getLabel());
		for(TypestateVar v: env)
			v.current = v.end.get(target);

		return true;
	}

	eq IfStmt.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v: env) {
			v.start.put(this, new LoopNode());
			v.end.put(this, v.current);
		}

		getThen().getGraph(env);

		for(TypestateVar v: env) {
			GraphNode s = v.start.get(this);
			s.addNext(v.current);
			v.current = v.end.remove(this);
		}

		if(hasElse()) 
			getElse().getGraph(env);

		for(TypestateVar v: env) {
			GraphNode s = v.start.remove(this);
			v.current = s.addNext(v.current);
		}

		getCondition().getGraph(env);

		return true;
	}

	eq WhileStmt.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v : env) {
			GraphNode n = new LoopNode();
			v.start.put(this, n);
			v.current = new LoopNode().addNext(v.current).addNext(n);
			v.end.put(this, v.current);
		}

		getStmt().getGraph(env);

		for(TypestateVar v: env) {
			GraphNode n = new LoopNode();
			n.addNext(v.current);
			n.addNext(v.end.get(this));
			v.current = n;
		}

		getCondition().getGraph(env);

		for(TypestateVar v: env) {
			GraphNode s = v.start.remove(this);
			v.current = s.addNext(v.current);
		}
		return true;
	}

	eq DoStmt.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v : env) {
			GraphNode n = new LoopNode();
			v.start.put(this, n);
			v.end.put(this, v.current);
			v.current = new LoopNode().addNext(v.current).addNext(n);
		}

		getCondition().getGraph(env);
		getStmt().getGraph(env);

		for(TypestateVar v: env) {
			GraphNode n = v.start.remove(this);
			n.addNext(v.current);
			v.current = n;
			v.end.remove(this);
		}

		return true;
	}

	eq ForStmt.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v: env) {
			GraphNode n = new LoopNode();
			v.start.put(this, n);
			v.end.put(this, v.current);
			v.current = n;
		}

		for(int i = getNumUpdateStmt() - 1; i >= 0; i--)
			getUpdateStmt(i).getGraph(env);

		getStmt().getGraph(env);

		for(TypestateVar v: env)
			v.current = new LoopNode().addNext(v.current).addNext(v.end.remove(this));

		if(hasCondition())
			getCondition().getGraph(env);

		for(int i = getNumInitStmt() - 1; i >= 0; i--)
			getInitStmt(i).getGraph(env);


		for(TypestateVar v: env)
			v.current = v.start.remove(this).addNext(v.current);

		return true;
	}

	eq SwitchStmt.getGraph(Set<TypestateVar> env) {
		Block b = getBlock();

		TypestateVar t = null;
		//TODO consider a link type for enumDecl variables
		if(getExpr().isAccess()) {
			Access a = ((Access) getExpr()).getLastAccess();
			if(a.getQualifiedType().isEnumDeclType())
				t = a.getQualifiedAccess() != null ?
				a.getQualifiedAccess().getQualifiedTypestateVar() :
				null;
		}

		for(TypestateVar v : env) {
			if(t == null || !t.equals(v))
				v.start.put(this, new LoopNode());
			else
				v.start.put(this, new SwitchNode());
			v.end.put(this, v.current);
		}
		boolean c = false;
		ArrayList<String> count = new ArrayList<String>();
		for(int i = b.getNumStmt() - 1; i >= 0; i--) {
			if(b.getStmt(i) instanceof ConstCase) {
				c = true;
				//TODO might not need the isAccess check and the else branch
				if(((ConstCase)b.getStmt(i)).getValue().isAccess())
					count.add(((Access)((ConstCase)b.getStmt(i)).getValue()).getLastAccess().toString());
				else
					count.add(((ConstCase)b.getStmt(i)).getValue().toString());
			}
			else if(b.getStmt(i) instanceof DefaultCase) {
				c = true;
				count.add("default");
			}
			else {
				if(c == true)
					for(TypestateVar v: env) {
						if(t == null || !t.equals(v))
							v.start.get(this).addNext(v.current);
						else {
							for(int j = 0; j < count.size(); j++) {
								SwitchCase sc = new SwitchCase(count.get(j));
								sc.addNext(v.current);
								v.start.get(this).addNext(sc);
							}
							count.clear();
						}
					}

				c = false;
				b.getStmt(i).getGraph(env);
			}
		}
		if(c == true)
			for(TypestateVar v: env) {
				if(t == null || !t.equals(v))
					v.start.get(this).addNext(v.current);
				else {
					for(int j = 0; j < count.size(); j++) {
						SwitchCase sc = new SwitchCase(count.get(j));
						sc.addNext(v.current);
						v.start.get(this).addNext(sc);
					}
					count.clear();
				}
			}

		for(TypestateVar v : env) {
			v.current = v.start.remove(this);
			v.end.remove(this);
		}

		getExpr().getGraph(env);

		return true;
	}

	//TODO another file
	inh MethodDecl Stmt.getMethodDeclAncestor();

	//TODO implement me
	eq ReturnStmt.getGraph(Set<TypestateVar> env) {
		if(!hasResult())
			return true;

		TypestateVar t = getResult().getTypestateVar();
		if(t != null)
			if(getMethodDeclAncestor().getTypeAccess().lookupType().isTypestateClassDeclType()) {
				t.checkError(getResult());
				t.current = getMethodDeclAncestor().getTypestateMethod().getTType().createTypestate(); //TODO cloneGraphNode ??
			}

		getResult().getGraph(env);

		return true;
	}

	eq VarDeclStmt.getGraph(Set<TypestateVar> env) {
		for(int i = getNumVariableDecl() - 1; i >= 0; i--)
			getVariableDecl(i).getGraph(env);
		return true;
	}

	//TODO implement me
	syn lazy boolean VariableDecl.getGraph(Set <TypestateVar> env) {
		boolean isTypestate = getTypeAccess().lookupType().isTypestateClassDeclType();
	
		if(isTypestate)
			env.remove(typestate);

		if(!hasInit())
			return true;

		TypestateVar t;
		if(isTypestate) {
			if(getInit() instanceof ClassInstanceExpr) {
				typestate.current = new InitNode().addNext(typestate.current);
				typestate.addTypestate(getInit());
			}
			else if((t = getInit().getTypestateVar()) != null) {
				t.checkError(getInit());
				t.current = typestate.current;
				//Typestate should be reset
				typestate.resetCurrent();
			}
		}

		getInit().getGraph(env);

		return false;
	}

/********************************************************************************************/
	syn boolean Expr.getGraph(Set<TypestateVar> env);

	//Not used
	eq AmbiguousAccess.getGraph(Set<TypestateVar> env) = false;
	eq VarAccess.getGraph(Set<TypestateVar> env) = false;
	eq SuperAccess.getGraph(Set<TypestateVar> env) = false;
	eq PackageOrTypeAccess.getGraph(Set<TypestateVar> env) = false;
	eq PackageAccess.getGraph(Set<TypestateVar> env) = false;

	//TODO implement me
	eq AssignExpr.getGraph(Set<TypestateVar> env) {
		getDest().getGraph(env);
		TypestateVar d = getDest().getTypestateVar();
		TypestateVar s;
		if(d != null) {
			if(getSource() instanceof ClassInstanceExpr) {
				d.current = new InitNode().addNext(d.current);
				d.addTypestate(getSource());
			}
			else if((s = getSource().getTypestateVar()) != null) {
				s.checkError(getSource());
				s.current = d.current;
				d.resetCurrent();
			}
		}
		getSource().getGraph(env);
		return true;
	}

	eq Literal.getGraph(Set<TypestateVar> env) = false;

	eq Binary.getGraph(Set<TypestateVar> env) {
		getRightOperand().getGraph(env);
		getLeftOperand().getGraph(env);
		return true;
	}

	eq LogicalExpr.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v : env)
			v.end.put(this, v.current);

		getRightOperand().getGraph(env);

		for(TypestateVar v: env)
			v.current = new LoopNode().addNext(v.current).addNext(v.end.remove(this));

		getLeftOperand().getGraph(env);

		return true;
	}

	eq ParExpr.getGraph(Set<TypestateVar> env) = getExpr().getGraph(env);

	eq ConditionalExpr.getGraph(Set<TypestateVar> env) {
		for(TypestateVar v : env)
			v.end.put(this, v.current);

		getTrueExpr().getGraph(env);

		for(TypestateVar v: env) {
			v.start.put(this, new LoopNode().addNext(v.current));
			v.current = v.end.remove(this);
		}

		getFalseExpr().getGraph(env);

		for(TypestateVar v: env)
			v.current = v.start.remove(this).addNext(v.current);

		getCondition().getGraph(env);

		return true;
	}

	eq InstanceOfExpr.getGraph(Set<TypestateVar> env) = getExpr().getGraph(env);

	eq CastExpr.getGraph(Set<TypestateVar> env) = getExpr().getGraph(env);
	eq Unary.getGraph(Set<TypestateVar> env) = getOperand().getGraph(env);


	eq ConstructorAccess.getGraph(Set<TypestateVar> env) {
		for(int i = getNumArg() - 1; i >= 0; i--)
			getArg(i).getGraph(env);
		return true;
	}

	eq ArrayInit.getGraph(Set<TypestateVar> env) {
		for(int i = getNumInit() - 1; i >= 0; i--)
			getInit(i).getGraph(env);
		return true;
	}

	eq ArrayCreationExpr.getGraph(Set<TypestateVar> env) {
		if(hasArrayInit())
			getArrayInit().getGraph(env);
		return true;
	}

	eq ParseName.getGraph(Set<TypestateVar> env) = true;
	eq ThisAccess.getGraph(Set<TypestateVar> env) = true;
	eq TypeAccess.getGraph(Set<TypestateVar> env) = true;
	eq ClassAccess.getGraph(Set<TypestateVar> env) = true;
	//Used when array access is qualified
	eq ArrayAccess.getGraph(Set<TypestateVar> env) = getExpr().getGraph(env);
	eq ArrayTypeAccess.getGraph(Set<TypestateVar> env) = getAccess().getGraph(env);
	eq ArrayTypeWithSizeAccess.getGraph(Set<TypestateVar> env) {
		getAccess().getGraph(env);
		getExpr().getGraph(env);
		return true;
	}

	eq AbstractDot.getGraph(Set<TypestateVar> env) {
		getRight().getGraph(env);
		getLeft().getGraph(env);
		return true;
	}

	//TODO another file???
	syn Set<VariableDecl> MethodAccess.getTypestateFields() = getClassDeclAncestor().getTypestateFields();

	//TODO implement me
	eq MethodAccess.getGraph(Set<TypestateVar> env) {
		MethodDecl md = lookupMethod(getQualifiedType());		//TODO what if it is null??
		if(md == null)
			return false;
		//TODO case of recursion
		if(isThisAccess()) {
			if(md.isGraph() == false)
				md.getGraph();
			for(VariableDecl vd : getTypestateFields())
				vd.typestate.getMethodGraph(md);
		}
		else if(getQualifiedType().isTypestateClassDeclType()) {
			TypestateVar t = getQualifiedTypestateVar();
			if (t != null)
				t.current = new MethodNode(getID(), getParameterTypes()).addNext(t.current);
		}

		for(int i = getNumArg() - 1; i >= 0; i--) {
			TypestateVar t = getArg(i).getTypestateVar();
			if(t != null) {
				t.checkError(getArg(i));
				t.current = md.getParameterTypestate(i);
			}
		}

		if(getType().isTypestateClassDeclType())
			typestate.addTypestate(this);

		return true;
	}

	eq ClassInstanceExpr.getGraph(Set<TypestateVar> env) = true;

}
