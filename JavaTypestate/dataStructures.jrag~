aspect dataStructures {
	/*
	 * Class GraphNode represents a node in the graph structure that
	 * represents a typestate type.
	 * **
	 * The class is abstract and it is inherited by classes:
	 * - MethodNode:	represents a state where a method call should be done.
	 * - LoopNode:		a node representing a state where you can choose on a set of continuations.
	 * - SwithNode:		represents a state where a method call must be done and depending
	 *			on the method call return value the state proceeds accordingly.
	 * - InitNode:		It is the initial node
	 * - EnodNode:		Used as the final state
	 * **
	 * The class is equipped with methods for:
	 * - Traversing a graph:
	 * - Checking equality between graphs.
	 * - Normalise a graph by removing all empty nodes.
	 * - Check if a graph has empty/loop nodes.
	 */

	abstract class GraphNode {
		private String signature;
		protected ArrayList<GraphNode> next;

		protected GraphNode(String m) {
			signature = m;
			next = new ArrayList<GraphNode>();
		}

		public String toString() {
			return signature != null ? signature : "";
		}

		public String signature() {
			return signature;
		}

		public GraphNode addNext(GraphNode n) {
			if(n != null)
				next.add(n);
			return this;
		}

		private boolean hasNext() {
			return next.size() != 0;
		}

		/**********************************************************/
		/*                Equivalence relations                   */
		/**********************************************************/

		/*
		 * Create a structure to store tuples (doubles) of GraphNode elements
		 * Tuples construct a closure of GraphNode to co-inductively check that two nodes were
		 * revisited at the same time by the "includes" algorithm.
		 */

		protected class TupleSet {
			private class TupleEntry {
				private GraphNode n1, n2;
				TupleEntry(GraphNode n1, GraphNode n2) {
					this.n1 = n1;
					this.n2 = n2;
				}

				public int hashCode() {
					return n1.hashCode() ^ n2.hashCode();
				}

				public boolean equals(Object o) {
					if(o instanceof TupleEntry) {
						TupleEntry te = (TupleEntry) o;
						return n1.equals(te.n1) && n2.equals(te.n2);
					}
					return false;
				}
			}

			Set<TupleEntry> relation;

			public TupleSet() {
				relation = new HashSet<TupleEntry>();
			}

			public boolean has(GraphNode firstNode, GraphNode secondNode) {
				return relation.contains(new TupleEntry(firstNode, secondNode));
			}

			public boolean insert(GraphNode firstNode, GraphNode secondNode) {
				return relation.add(new TupleEntry(firstNode, secondNode));
			}

			public boolean remove(GraphNode firstNode, GraphNode secondNode) {
				return relation.remove(new TupleEntry(firstNode, secondNode));
			}
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(ts.has(this, n) || (!hasNext() && !n.hasNext()))
				return true;

			ts.insert(this, n);
			for(GraphNode n1 : n.next) {
//			for(int i = 0; i < n.next.size(); i++) {
				boolean b = false;
				for(GraphNode n2: next)
//				for(int j = 0; j < next.size(); j++)
					if(b = n2/*next.get(j)*/.includes(n1/*n.next.get(i)*/, ts))
						break;

				if(b == false) {
					ts.remove(this, n);
					return false;
				}
			}
			return true;
		}

		protected boolean includes(GraphNode n) {
			return includes(n, new TupleSet());
		}

		// Polymorphic on SwitchNode
		protected boolean equalNode(GraphNode n) {
			return signature.equals(n.signature());
		}

//		protected boolean postfix(GraphNode n) {
//			if(this.includes(n))			//TODO check every subtree
//				return true;
//			//TODO how about recursion???
//			for(int i = 0; i < next.size(); i++)
//				if(next.get(i).postfix(n))
//					return true;
//			return false;
//		}

		/**************************************************************/
		/*                     Normalise Graph                        */
		/**************************************************************/

		protected boolean isNodeVisited(Set<GraphNode> visitedSet) {
			if(visitedSet.contains(this))
				return true;
			visitedSet.add(this);
			return false;
		}

		protected void removeVisited(Set<GraphNode> visitedSet) {
			visitedSet.remove(this);
		}

		// Polymorphic on LoopNode
		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return false;
			for(GraphNode n: next)
//			for(int i = 0; i < next.size(); i++)
				if(n/*next.get(i)*/.__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		private boolean hasLoopNode() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			for(GraphNode n: next)
//			for(int i = 0; i < next.size(); i++)
				if(n/*next.get(i)*/.__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		// Polymorphic on LoopNode
		protected ArrayList<GraphNode> nextArrayList() {
			ArrayList<GraphNode> a = new ArrayList<GraphNode>();
			a.add(this);
			return a;
		}

		// Polymorphic on SwitchNode, LoopNode
		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return next.get(i).normalise(visitedSet);
		}

		/* 
		 * Remove LoopNodes from its graph
		 */
		protected ArrayList<GraphNode> normalise(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return nextArrayList();

			ArrayList<GraphNode> tmpNext = new ArrayList<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				tmpNext.addAll(computeNextArrayList(i, visitedSet));
			next = tmpNext;

			return nextArrayList();
		}

		protected GraphNode normalise() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			ArrayList<GraphNode> alist = new ArrayList<GraphNode>();
			for(GraphNode n: next)
//			for(int i = 0; i < next.size(); i++)
				if(!this.equals(n/*next.get(i)*/))
					alist.addAll(n/*next.get(i)*/.normalise(visitedSet));
			next = alist;
			return hasLoopNode() ? normalise() : this;
		}

		/***********************************************************/
		/*               Count EndNodes/Ignore LoopNodes           */
		/***********************************************************/

		//polymorphic
		abstract public int onlyEndNodes();

		/***********************************************************/
		/*               Count EndNodes/Ignore LoopNodes           */
		/***********************************************************/

		abstract public GraphNode cloneNode();

		public GraphNode copyNode() {
			GraphNode n = cloneNode();
			for(GraphNode g : next)
				n.addNext(g.copyNode());
			return n;
		}

		/***********************************************************/
		/*                For Debug                                */
		/***********************************************************/

		// Polymorphic on SwitchNode -> Adds switch case
		protected void setSwitchCase(int i) {}

		private void printPaths(String s, Set<GraphNode> visitedSet) {
			if((next.size() == 0) || isNodeVisited(visitedSet)) {
				System.out.println(s + toString());
				return;
			}
			for(int i = 0; i < next.size(); i++) {
				setSwitchCase(i);
				next.get(i).printPaths(s + toString(), visitedSet);
			}
			removeVisited(visitedSet);
		}

		public void printPaths() {
			Set<GraphNode> s = new HashSet<GraphNode>();
			printPaths("", s);
		}
	}

	/*
	 * MethodNode inherits GraphNode
	 * Instantiates a class that represents a method call.
	 */
	public class MethodNode extends GraphNode {
		public MethodNode(String m) {
			super(m);
		}

		public String toString() {
			return super.toString() + ";";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof MethodNode)
				return equalNode(n) ? super.includes(n, ts) : false;
			return false;
		}

		public int onlyEndNodes() {
			return -1;
		}

		public GraphNode cloneNode() {
			return new MethodNode(signature());
		}
//		public GraphNode copyNode() {
//			MethodNode m = new MethodNode(signature());
//			for(GraphNode n : next)
//				m.addNext(n.copyNode());
//			return m;
//		}
	}

	/*
	 * SwitchNode inherits GraphNode.
	 * Instantiates a class that represents a state where
	 * the continuing state is depended on the result
	 * of the previous method call.
	 */
	public class SwitchNode extends GraphNode {
		private String scase;
		private ArrayList<String> expr;

		public SwitchNode() {
			super(null);
			scase = null;
			expr = new ArrayList<String>();
		}

		public GraphNode addNext(GraphNode n) {
			return addNext(n, null);
		}

		public GraphNode addNext(GraphNode n, String e) {
			super.addNext(n);
			if(n != null)
				expr.add(e);
			return this;
		}

		public String toString() {
			return scase != null ? scase + ":" : ";";
		}

		protected void setSwitchCase(int i){
			scase = expr.get(i);
		}

		// Used in computeNextArray
		private ArrayList<String> tmpExpr; 
		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			if(i == 0)
				 tmpExpr = new ArrayList<String>();
			ArrayList<GraphNode> alist = next.get(i).normalise(visitedSet);
			for(int j = 0; j < alist.size(); j++)
				tmpExpr.add(expr.get(i));

			if(i == next.size() - 1)
				expr = tmpExpr;
			return alist;
		}

		protected boolean equalNode(GraphNode n) {
			SwitchNode sn = (SwitchNode) n;
			for(String s : sn.expr)
//			for(int i = 0; i < sn.expr.size(); i++)
				if(!(expr.contains(s/*sn.expr.get(i)*/)))
					return false;
			return true;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof SwitchNode)
				return equalNode(n) ? super.includes(n, ts) : false;
			return false;
		}

		public GraphNode cloneNode() {
			return new SwitchNode();
		}

		public GraphNode copyNode() {
			SwitchNode s = new SwitchNode();
			for(int i = 0; i < next.size(); i++)
				s.addNext(next.get(i).copyNode(), expr.get(i));
			return s;
		}

		public int onlyEndNodes() {
			return -1;
		}
	}

	/*
	 * LoopNode inherits GraphNode.
	 * Auxiliary Node for creating a typestate graph
	 * Represents a state where there is a possible recursion.
	 */
	public class LoopNode extends GraphNode {
		public LoopNode() {
			super(null);
		}

		public String toString() { 
			return "Label " + super.toString() + ":";
		}

		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			return true;
		}

		protected ArrayList<GraphNode> nextArrayList() {
			return next;
		}

		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return (!this.equals(next.get(i))) ? next.get(i).normalise(visitedSet) : new ArrayList<GraphNode>();
		}

		public GraphNode cloneNode() {
			return new LoopNode();
		}

//		public GraphNode copyNode() {
//			LoopNode l = new LoopNode();
//			for(GraphNode n : next)
//				l.addNext(n.copyNode());
//			return l;
//		}

		public int onlyEndNodes() {
			int sum = 0;
			int result;
			for(GraphNode n: next) {
//			for(int i = 0; i < next.size(); i++) {
				result = n/*next.get(i)*/.onlyEndNodes();
				if(result == -1)
					return -1;
				sum += result;
			}
			return sum;
		}
	}

	/*
	 * EndNode inherits GraphNode
	 * Represents the final state.
	 */
	public class EndNode extends GraphNode {
		protected EndNode() {
			super(null);
		}

		public String toString() {
			return "End Node;";
		}

		public GraphNode addNext(GraphNode n) {
			return this;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof EndNode)
				return super.includes(n, ts);
			return false;
		}

		public GraphNode cloneNode() {
			return new EndNode();
		}

//		public GraphNode copyNode() {
//			return new EndNode();
//		}

		public int onlyEndNodes() {
			return 1;
		}
	}

	/*
	 * InitNode inherits GraphNode
	 * Represents the initial state.
	 */
	public class InitNode extends GraphNode {
		protected InitNode() {
			super(null);
		}

		public String toString() {
			return "Init Node;";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof InitNode)
				return super.includes(n, ts);
			return false;
		}

		public GraphNode cloneNode() {
			return new InitNode();
		}

//		public GraphNode copyNode() {
//			InitNode i = new InitNode();
//			for(GraphNode n : next)
//				i.addNext(n.copyNode());
//			return i;
//		}

		public int onlyEndNodes() {
			return -1;
		}
	}

	/*******************************************************************************/
	/*                 Type Environment Structures                                 */
	/*******************************************************************************/

	class TypestateVar {
		GraphNode current;
		Map<ASTNode, GraphNode> end;
		Map<ASTNode, GraphNode> start;

		/*private*/ ArrayList<GraphNode> startTypestate; //TODO make private
		/*private*/ ArrayList<Expr> exprASTNode;
		/*private*/ ArrayList<GraphNode> errorTypestate; //TODO make private
		/*private*/ ArrayList<Expr> errorExpr;

		TypestateVar() {
			current = new EndNode();		//TODO LoopEndNode();
			end = new HashMap<ASTNode, GraphNode>();
			start = new HashMap<ASTNode, GraphNode>();
			startTypestate = new ArrayList<GraphNode>();
			exprASTNode = new ArrayList<Expr>();

			errorTypestate = new ArrayList<GraphNode>();
			errorExpr = new ArrayList<Expr>();
		}

		void addTypestate(Expr e) {
			startTypestate.add(current);
			exprASTNode.add(e);
			resetCurrent();
		}

		protected void addErrorTypestate(Expr e) {
			errorTypestate.add(current);
			errorExpr.add(e);
			resetCurrent();
		}

		void checkError(Expr e) {
			if(current.onlyEndNodes() == -1)		//has more than EndNodes/LoopNodes
				addErrorTypestate(e);
		}

		void resetCurrent() {
			current = new EndNode();
		}

		void addConnectionTypestate(MethodDecl m) {}
		GraphNode getConnectionTypestate() {
			return null;
		}
	}

	class TypestatePar extends TypestateVar {
		private LoopNode parameterNode;

		TypestatePar() {
			super();
			parameterNode = new LoopNode();
		}

		void addConnectionTypestate(MethodDecl m) {		//TODO dont like
			parameterNode.addNext(current);
		}

		GraphNode getConnectionTypestate() {
			return parameterNode;
		}
	}

	class TypestateField extends TypestateVar {
		private Map<MethodDecl, GraphNode> methodStartNode;
		private Map<MethodDecl, GraphNode> methodEndGraph;
		private Map<MethodDecl, GraphNode> methodEndNode;
		private Map<MethodDecl, Expr> methodEndExpr;
		private GraphNode endNode;
		private GraphNode endGraph;
		private Expr endExpr;

		TypestateField() {
			super();
			methodStartNode = new HashMap<MethodDecl, GraphNode>();
			methodEndGraph = new HashMap<MethodDecl, GraphNode>();
			methodEndNode = new HashMap<MethodDecl, GraphNode>();
			methodEndExpr = new HashMap<MethodDecl, Expr>();
			endNode = new LoopNode();
			current = endNode;
			endGraph = null;
			endExpr = null;
		}

		void addTypestate(Expr e) {
			if(startTypestate.size() == 0 && endGraph == null) {
				endGraph = current;
				endExpr = e;
			}
			else {
				startTypestate.add(current);
				exprASTNode.add(e);
			}
			resetCurrent();
		}

		void checkError(Expr e) {
			if(current.onlyEndNodes() == -1)		//if has more than EndNodes/LoopNodes
				addErrorTypestate(e);
			else if(current.onlyEndNodes() == 0)		//if has only LoopNodes
				addTypestate(e);			//TODO add them somewhere for future check for only end/loopnode
		}

		void addConnectionTypestate(MethodDecl m) {
			if(endGraph == null)			//EndGraph is the same as startNode
				endGraph = current;

			methodStartNode.put(m, current);
			methodEndNode.put(m, endNode);
			methodEndGraph.put(m, endGraph);
			endNode = new LoopNode();
			current = endNode;
			endGraph = null;
			endExpr = null;
		}
	}
}
