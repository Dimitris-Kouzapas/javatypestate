aspect RewriteAccess {

	private boolean Access.doRewrite = true;
//	TODO the idea is to iterate the rewrite operation until the getLeft() of an
//	abstractDot is not a package Access or it is not an abstractdot anymore
	rewrite Access {
		when (doRewrite && isDotPackage() != null) to Access {
			Access dot = ((AbstractDot) this).getRight();
			ParseName left = (ParseName) ((AbstractDot) this).getLeft();

			if(dot.isAbstractDot()) {
				AbstractDot right = (AbstractDot) dot;
				if(right.getLeft() instanceof ParseName) {
					ParseName n = (ParseName) right.getLeft();
					PackageParseName p = new PackageParseName(n.getName(), left.getName());
					right.setLeft(p);
					System.out.println("==" + right);
					return right;
				}
			}
			else if(dot instanceof ParseName) {
				PackageParseName p = new PackageParseName(((ParseName) dot).getName(), left.getName());
				System.out.println("++" + p);
//				return new PackageParseName(((ParseName) getLeft()).getName(), ((ParseName) getRight()).getName());
				return p;
			}
			doRewrite = false;		//TODO change the variable name
			return this;
		}
	}


	syn boolean Access.isDotPackage() = false;
	eq AbstractDot.isDotPackage() =
		!isAbstractDotParent() && !(getParent() instanceof ImportDecl) && isPackageAccess();


	syn boolean Expr.isPackageAccess(Access a) = false;
	eq AbstractDot.getPackageAccess(Access a) {
		if(a instanceof ParseName)
			return getLeft().getPackageAccess((ParseName) getRight());
		else if(a instanceof AbstractDot)
			return getLeft().getPackage((AbstractDot) getRight());
		return null;
	}

	eq ParseName.getPackageAccess(ParseName p) =
		isPackage(getName() + "." + p.getName()) ? new PackageParseName(getName() + "." + p.getName()) : null;

	eq ParseName.getPackageAccess(AbstractDot p) =
		(p.getLeft() instanceof ParseName) ? getPackage(p.getLeft()): null;

//	eq ParseName.isPackageAccess() = isPackage(getID());
//	eq PackageParseName.isPackageAccess() = isPackage(getPackage() + "." + getID());

	protected void PackageParseName.Rewrite(TypestateStream stream) {
		stream.print("--->" + getName() + "<----");
	}

	syn lazy String ParseName.getName() = getID();
	eq PackageParseName.getName() = getPackage() + "." + getID();

	inh boolean ParseName.isPackage(String Package);
//	syn lazy TypeDecl ParseName.lookupPackage(PackageType p) = lookupPackage(p.getID(), getID());
//	syn lazy TypeDecl ParseName.lookupPackage() = lookupPackage("", getID());

	eq CompilationUnit.getImportDecl(int i).isPackage(String Package) = false;
	eq CompilationUnit.getTypeDecl().isPackage(String Package) = isPackage(Package);

	syn boolean CompilationUnit.isPackage(String Package) {

	//	String p = (Package.equals("") ? "" : Package + ".") + name;

		if(getPackageDecl().startsWith(Package))// && !getPackageDecl().equals(Package))
			return true; //new PackageType(p);
		for(int i = 0; i < getNumImportDecl(); i++)
			if(getImportDecl(i).startsWith(Package))
				return true;// new PackageType(p);

		return false;
//		return lookupType(Package, name);
	}

//	syn lazy boolean ImportDecl.startsWith(String Package);
//	eq SingleTypeImportDecl.startsWith(String Package) = 
//		getAccess().toString().startsWith(Package) && !getAccess().toString().equals(Package);
//	eq TypeImportOnDemandDecl.startsWith(String Package) = getAccess().toString().startsWith(Package);		

}
