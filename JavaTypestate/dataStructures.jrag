aspect dataStructures {
	/*
	 * Class GraphNode represents a node in the graph structure that
	 * represents a typestate type.
	 * **
	 * The class is abstract and it is inherited by classes:
	 * - MethodNode:	represents a state where a method call should be done.
	 * - LoopNode:		a node representing a state where you can choose on a set of continuations.
	 * - SwithNode:		represents a state where a method call must be done and depending
	 *			on the method call return value the state proceeds accordingly.
	 * - InitNode:		It is the initial node
	 * - EnodNode:		Used as the final state
	 * **
	 * The class is equipped with methods for:
	 * - Traversing a graph:
	 * - Checking equality between graphs.
	 * - Normalise a graph by removing all empty nodes.
	 * - Check if a graph has empty/loop nodes.
	 */

	abstract class GraphNode {
		private String id;
		private TypeDecl[] parameters;
		protected ArrayList<GraphNode> next;

		protected GraphNode(String id, TypeDecl[] parameters) {
			this.id = id;
			this.parameters = parameters;
			signature = null;
			next = new ArrayList<GraphNode>();
		}

		private String signature;

		public String toString() {
			if (signature != null)
				return signature;

			if(id == null)
				return signature = "";

			signature = id + "(";
			for(int i = 0; i < parameters.length; i++) {
				if(i != 0)
					signature += ", ";
				signature += parameters[i].getID();
			}
			return signature += ")";
		}

		public String getId() {
			return id;
		}

		public TypeDecl[] getParameters() {
			return parameters;
		}

		public GraphNode addNext(GraphNode n) {
			if(n != null)
				next.add(n);
			return this;
		}

		private boolean hasNext() {
			return next.size() != 0;
		}

		/**********************************************************/
		/*                Equivalence relations                   */
		/**********************************************************/

		/*
		 * Create a structure to store tuples (doubles) of GraphNode elements
		 * Tuples construct a closure of GraphNode to co-inductively check that two nodes were
		 * revisited at the same time by the "includes" algorithm.
		 */

		protected class TupleSet {
			private class TupleEntry {
				private GraphNode n1, n2;
				TupleEntry(GraphNode n1, GraphNode n2) {
					this.n1 = n1;
					this.n2 = n2;
				}

				public int hashCode() {
					return n1.hashCode() ^ n2.hashCode();
				}

				public boolean equals(Object o) {
					if(o instanceof TupleEntry) {
						TupleEntry te = (TupleEntry) o;
						return n1.equals(te.n1) && n2.equals(te.n2);
					}
					return false;
				}
			}

			Set<TupleEntry> relation;

			public TupleSet() {
				relation = new HashSet<TupleEntry>();
			}

			public boolean has(GraphNode firstNode, GraphNode secondNode) {
				return relation.contains(new TupleEntry(firstNode, secondNode));
			}

			public boolean insert(GraphNode firstNode, GraphNode secondNode) {
				return relation.add(new TupleEntry(firstNode, secondNode));
			}

			public boolean remove(GraphNode firstNode, GraphNode secondNode) {
				return relation.remove(new TupleEntry(firstNode, secondNode));
			}
		}
		protected boolean includes(GraphNode n, TupleSet ts) {
			if(ts.has(this, n) || (!hasNext() && !n.hasNext()))
				return true;

			ts.insert(this, n);
			for(GraphNode n1 : n.next) {
				boolean b = false;
				for(GraphNode n2: next)
					if(b = n2.includes(n1, ts))
						break;

				if(b == false) {
					ts.remove(this, n);
					return false;
				}
			}
			return true;
		}

		protected boolean includes(GraphNode n) {
			return includes(n, new TupleSet());
		}

		/**************************************************************/
		/*                     Normalise Graph                        */
		/**************************************************************/

		protected boolean isNodeVisited(Set<GraphNode> visitedSet) {
			if(visitedSet.contains(this))
				return true;
			visitedSet.add(this);
			return false;
		}

		protected void removeVisited(Set<GraphNode> visitedSet) {
			visitedSet.remove(this);
		}

		// Polymorphic on LoopNode
		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return false;
			for(GraphNode n: next)
				if(n.__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		private boolean hasLoopNode() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			for(GraphNode n: next)
				if(n.__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		// Polymorphic on LoopNode
		protected ArrayList<GraphNode> nextArrayList() {
			ArrayList<GraphNode> a = new ArrayList<GraphNode>();
			a.add(this);
			return a;
		}

		// Polymorphic on LoopNode
		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return next.get(i).normalise(visitedSet);
		}

		/* 
		 * Remove LoopNodes from its graph
		 */
		protected ArrayList<GraphNode> normalise(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return nextArrayList();

			ArrayList<GraphNode> tmpNext = new ArrayList<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				for(GraphNode n : computeNextArrayList(i, visitedSet))
					if(!tmpNext.contains(n))
						tmpNext.add(n);
			next = tmpNext;

			return nextArrayList();
		}

		protected GraphNode normalise() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			ArrayList<GraphNode> alist = new ArrayList<GraphNode>();
			for(GraphNode n: next)
				if(!this.equals(n))
					alist.addAll(n.normalise(visitedSet));
			next = alist;
			return hasLoopNode() ? normalise() : this;
		}

		/***********************************************************/
		/*               Count EndNodes/Ignore LoopNodes           */
		/***********************************************************/

		//polymorphic on LoopNode, EndNode
		protected int onlyEndNodes(Set<LoopNode> visited) {
			return -1;
		}

		public int onlyEndNodes() {
			return onlyEndNodes(new HashSet<LoopNode>());
		}

		/***********************************************************/
		/*               Clone Graphs			           */
		/***********************************************************/

		abstract protected GraphNode cloneNode();

		GraphNode cloneGraph(GraphNode end) {
			return cloneGraph(end, new HashMap<GraphNode, GraphNode>());
		}

		//Polymorphic on LoopNode
		GraphNode cloneGraph(GraphNode end, Map<GraphNode, GraphNode> visited) {
			if(visited.get(this) != null)
				return visited.get(this);

			GraphNode r = cloneNode();
			visited.put(this, r);

			for(GraphNode n: next)
				r.addNext(n.cloneGraph(end, visited));

			return r;
		}

		/***********************************************************/
		/*                For Debug                                */
		/***********************************************************/

		private void printPaths(String s, Set<GraphNode> visitedSet) {
			if((next.size() == 0) || isNodeVisited(visitedSet)) {
				System.out.println(s + toString());
				return;
			}

			for(int i = 0; i < next.size(); i++)
				next.get(i).printPaths(s + toString(), visitedSet);

			removeVisited(visitedSet);
		}

		public void printPaths() {
			Set<GraphNode> s = new HashSet<GraphNode>();
			printPaths("", s);
		}
	}

	/********************************************************************************/
	/*                       Graph Nodes                                            */ 
	/********************************************************************************/

	/*
	 * MethodNode inherits GraphNode
	 * Instantiates a class that represents a method call.
	 */
	public class MethodNode extends GraphNode {
		public MethodNode(String id, TypeDecl[] parameters) {
			super(id, parameters);
		}

		public String toString() {
			return super.toString() + ";";
		}

		protected boolean equalNode(GraphNode n) {
			if(!(n instanceof MethodNode))
				return false;

			if(!n.getId().equals(getId()) || n.getParameters().length != getParameters().length)
				return false;

			for(int i = 0; i < n.getParameters().length; i++) {
				TypeDecl t = n.getParameters()[i];//.getTypeAccess().lookupType();
				//null type should not be matched with primitive type
				//noname type should be matched with any type
				//t can never be instanceof NullType
				//overriden equals(Object o) method
				if(!getParameters()[i].equals(t) && !(t instanceof NoNameType))
					return false;
			}

			return true;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			return equalNode(n) ? super.includes(n, ts) : false;
		}

		protected GraphNode cloneNode() {
			return new MethodNode(getId(), getParameters());
		}
	}

	public class SwitchCase extends GraphNode {
		public SwitchCase(String id) {
			super(id, null);
		}

		public String toString() {
			return getId() + ":";
		}

		public boolean includes(GraphNode n, TupleSet ts) {
			if((n instanceof SwitchCase) && getId().equals(n.getId()))
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new SwitchCase(getId());
		}
	}

	/*
	 * SwitchNode inherits GraphNode.
	 * Instantiates a class that represents a state where
	 * the continuing state is depended on the result
	 * of the previous method call.
	 */
	public class SwitchNode extends GraphNode {
		public SwitchNode() {
			super(null, null);
		}

		public String toString() {
			return "";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof SwitchNode) 
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new SwitchNode();
		}
	}
	
	/*
	 * LoopNode inherits GraphNode.
	 * Auxiliary Node for creating a typestate graph
	 * Represents a state where there is a possible recursion.
	 */
	public class LoopNode extends GraphNode {
		public LoopNode() {
			super(null, null);
		}

		public String toString() { 
			return "Loop Node;";
		}

		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			return true;
		}

		protected ArrayList<GraphNode> nextArrayList() {
			return next;
		}

		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return (!this.equals(next.get(i))) ? super.computeNextArrayList(i, visitedSet) : new ArrayList<GraphNode>();
		}

		protected GraphNode cloneNode() {
			return new LoopNode();
		}

		GraphNode cloneGraph(GraphNode end, Map<GraphNode, GraphNode> visited) {
			//This means that the graph ends in a LoopNode -> the graph is still incomplete
			if(next.size() == 0)
				return cloneNode().addNext(end);
			return super.cloneGraph(end, visited);
		}

		protected int onlyEndNodes(Set<LoopNode> visited) {
			if(visited.contains(this))
				return 0;
			visited.add(this);
			int sum = 0;
			int result;
			for(GraphNode n: next) {
				result = n.onlyEndNodes(visited);
				if(result == -1)
					return -1;
				sum += result;
			}
			return sum;
		}
	}

	/*
	 * EndNode inherits GraphNode
	 * Represents the final state.
	 */
	public class EndNode extends GraphNode {
		protected EndNode() {
			super(null, null);
		}

		public String toString() {
			return "End Node;";
		}

		public GraphNode addNext(GraphNode n) {
			return this;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof EndNode)
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new EndNode();
		}

		protected int onlyEndNodes(Set<LoopNode> visited) {
			return 1;
		}
	}

	/*
	 * InitNode inherits GraphNode
	 * Represents the initial state.
	 */
	public class InitNode extends GraphNode {
		protected InitNode() {
			super(null, null);
		}

		public String toString() {
			return "Init Node;";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof InitNode)
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new InitNode();
		}
	}

	/*******************************************************************************/
	/*                 Type Environment Structures                                 */
	/*******************************************************************************/

	class TypestateVar {
		GraphNode current;
		Map<ASTNode, GraphNode> end;
		Map<ASTNode, GraphNode> start;

		private ArrayList<GraphNode> startTypestate;
		private ArrayList<Expr> exprASTNode;
		private ArrayList<GraphNode> errorTypestate;
		private ArrayList<ASTNode> errorNode;

		TypestateVar() {
			current = new EndNode();
			end = new HashMap<ASTNode, GraphNode>();
			start = new HashMap<ASTNode, GraphNode>();
			startTypestate = new ArrayList<GraphNode>();
			exprASTNode = new ArrayList<Expr>();

			errorTypestate = new ArrayList<GraphNode>();
			errorNode = new ArrayList<ASTNode>();
		}

		void addTypestate(Expr e) {
			startTypestate.add(current);
			exprASTNode.add(e);
			resetCurrent();
		}

		private void addErrorTypestate(ASTNode e) {
			errorTypestate.add(current);
			errorNode.add(e);
			resetCurrent();
		}

		void checkError(ASTNode e) {
			//has more than EndNodes/LoopNodes
			if(current.onlyEndNodes() == -1)
				addErrorTypestate(e);
		}

		protected void resetCurrent() {
			current = new EndNode();
		}

		void addConnectionTypestate(MethodDecl m) {}

		GraphNode getConnectionTypestate() {
			return null;
		}

		void getMethodGraph(MethodDecl m) {}

		void reportErrors(String errorMessage) {
			for(int i = errorTypestate.size() - 1; i >= 0; i--)
				errorNode.get(i).addSemanticError(errorMessage);
		}

		void checkTypestate(GraphNode t, String errorMessage) {
			for(int i = startTypestate.size() - 1; i >= 0; i--) {
				GraphNode n = startTypestate.get(i);
				n.normalise();
//				System.out.println("-----------------------");
//				n.printPaths();
//				System.out.println("------------------------");
				if(!t.includes(n))
					exprASTNode.get(i).addSemanticError(errorMessage);
			}

		}
	}

	class TypestatePar extends TypestateVar {
		private LoopNode parameterNode;

		TypestatePar() {
			super();
			parameterNode = new LoopNode();
		}

		void addConnectionTypestate(MethodDecl m) {		//TODO dont like
			parameterNode.addNext(current);
		}

		GraphNode getConnectionTypestate() {
			return parameterNode;
		}
	}

	class TypestateAccess extends TypestateVar {
		TypestateAccess() {
			super();
		}

		void addTypestate(Expr e) {
			current = new LoopNode().addNext(current);
			super.addTypestate(e);
		}	
	}

	class TypestateField extends TypestateVar {
		private Map<MethodDecl, GraphNode> methodStartGraph;
		private Map<MethodDecl, GraphNode> methodEndGraph;
		private Map<MethodDecl, Expr> methodEndExpr;

//		private GraphNode startNode;
//		private GraphNode endNode;

		private GraphNode endGraph;
		private Expr endExpr;

		TypestateField() {
			super();
			methodStartGraph = new HashMap<MethodDecl, GraphNode>();
			methodEndGraph = new HashMap<MethodDecl, GraphNode>();
			methodEndExpr = new HashMap<MethodDecl, Expr>();
//			startNode = new LoopNode();
			current = new LoopNode();
//			current = endNode = new LoopNode().addNext(current);
			endGraph = null;
			endExpr = null;
		}

		void addTypestate(Expr e) {
			if(endGraph == null) {
				endGraph = current;
				endExpr = e;
				resetCurrent();
			}
			else {
				super.addTypestate(e);
			}
		}

		void checkError(ASTNode e) {
			super.checkError(e);
			//if has only LoopNodes
			if(current.onlyEndNodes() == 0)
				addTypestate((Expr) e);		//TODO add them somewhere for future check for only end/loopnode
								//TODO is it a fact that at this point we expect e to be an Expr?
		}

		void addConnectionTypestate(MethodDecl m) {
			//EndGraph is the same as startNode
//			startNode.addNext(current);
			if(endGraph == null)
				endGraph = current;
//				endGraph = startNode;

			methodStartGraph.put(m, current);
//			methodStartGraph.put(m, startNode);//current);
			methodEndGraph.put(m, endGraph);
			methodEndExpr.put(m, endExpr);
//			startNode = new LoopNode();
			current = new LoopNode();
//			current = endNode = new LoopNode().addNext(current);
			endGraph = null;
			endExpr = null;
		}

		void getMethodGraph(MethodDecl md) {
			md.getGraph();				//TODO Call getGraph before you call this method
			GraphNode n1 = methodStartGraph.get(md);
			GraphNode n2 = methodEndGraph.get(md);

			if(!n1.equals(n2)) {
				current = n2.cloneGraph(current);
				if(current.onlyEndNodes() == -1)
					super.addTypestate(methodEndExpr.get(md));
			}
			current = n1.cloneGraph(current);
		}
	}
}
