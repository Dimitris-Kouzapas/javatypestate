aspect graphNode {
	/*
	 * Class GraphNode represents a node in the graph structure that
	 * represents a typestate type.
	 * **
	 * The class is abstract and it is inherited by classes:
	 * - MethodNode:	represents a state where a method call should be done.
	 * - LoopNode:		a node representing a state where you can choose on a set of continuations.
	 * - SwithNode:		represents a state where a method call must be done and depending
	 *			on the method call return value the state proceeds accordingly.
	 * - InitNode:		It is the initial node
	 * - EnodNode:		Used as the final state
	 * **
	 * The class is equipped with methods for:
	 * - Traversing a graph:
	 * - Checking equality between graphs.
	 * - Normalise a graph by removing all empty nodes.
	 * - Check if a graph has empty/loop nodes.
	 */

	abstract class GraphNode {
		private String id;
		private TypeDecl[] parameters;
		protected ArrayList<GraphNode> next;

		protected GraphNode(String id, TypeDecl[] parameters) {
			this.id = id;
			this.parameters = parameters;
			signature = null;
			next = new ArrayList<GraphNode>();
		}

		private String signature;

		public String toString() {
			if (signature != null)
				return signature;

			if(id == null)
				return signature = "";

			signature = id + "(";
			for(int i = 0; i < parameters.length; i++) {
				if(i != 0)
					signature += ", ";
				signature += parameters[i].getID();
			}
			return signature += ")";
		}

		protected String getId() {
			return id;
		}

		protected TypeDecl[] getParameters() {
			return parameters;
		}

		public GraphNode addNext(GraphNode n) {
			if(n != null)
				next.add(n);
			return this;
		}

		protected boolean hasNext() {
			return next.size() != 0;
		}

		/**********************************************************/
		/*                Equivalence relations                   */
		/**********************************************************/

		/*
		 * Create a structure to store tuples (doubles) of GraphNode elements
		 * Tuples construct a closure of GraphNode to co-inductively check that two nodes were
		 * revisited at the same time by the "includes" algorithm.
		 */

		protected class TupleSet {
			private class TupleEntry {
				private GraphNode n1, n2;
				TupleEntry(GraphNode n1, GraphNode n2) {
					this.n1 = n1;
					this.n2 = n2;
				}

				public int hashCode() {
					return n1.hashCode() ^ n2.hashCode();
				}

				public boolean equals(Object o) {
					if(o instanceof TupleEntry) {
						TupleEntry te = (TupleEntry) o;
						return n1.equals(te.n1) && n2.equals(te.n2);
					}
					return false;
				}
			}

			Set<TupleEntry> relation;

			protected TupleSet() {
				relation = new HashSet<TupleEntry>();
			}

			protected boolean has(GraphNode firstNode, GraphNode secondNode) {
				return relation.contains(new TupleEntry(firstNode, secondNode));
			}

			protected boolean insert(GraphNode firstNode, GraphNode secondNode) {
				return relation.add(new TupleEntry(firstNode, secondNode));
			}

			protected boolean remove(GraphNode firstNode, GraphNode secondNode) {
				return relation.remove(new TupleEntry(firstNode, secondNode));
			}
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(ts.has(this, n) || (!hasNext() && !n.hasNext()))
				return true;

			ts.insert(this, n);
			for(GraphNode n1 : n.next) {
				boolean b = false;
				for(GraphNode n2: next)
					if(b = n2.includes(n1, ts))
						break;

				if(b == false) {
					ts.remove(this, n);
					return false;
				}
			}
			return true;
		}

		public boolean includes(GraphNode n) {
			return includes(n, new TupleSet());
		}

		/**************************************************************/
		/*                     Normalise Graph                        */
		/**************************************************************/

		protected boolean isNodeVisited(Set<GraphNode> visited) {
			if(visited.contains(this))
				return true;
			visited.add(this);
			return false;
		}

		protected void removeVisited(Set<GraphNode> visited) {
			visited.remove(this);
		}

		// Polymorphic on LoopNode
		protected boolean __hasLoopNode(Set<GraphNode> visited) {
			if(isNodeVisited(visited))
				return false;
			for(GraphNode n: next)
				if(n.__hasLoopNode(visited))
					return true;
			return false;
		}

		private boolean hasLoopNode() {
			Set<GraphNode> visited = new HashSet<GraphNode>();
			for(GraphNode n: next)
				if(n.__hasLoopNode(visited))
					return true;
			return false;
		}

		// Polymorphic on LoopNode
		protected ArrayList<GraphNode> nextArrayList() {
			ArrayList<GraphNode> a = new ArrayList<GraphNode>();
			a.add(this);
			return a;
		}

		// Polymorphic on LoopNode
		protected ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visited) {
			return next.get(i).normalise(visited);
		}

		/* 
		 * Remove LoopNodes from its graph
		 */
		protected ArrayList<GraphNode> normalise(Set<GraphNode> visited) {
			if(isNodeVisited(visited))
				return nextArrayList();

			ArrayList<GraphNode> tmpNext = new ArrayList<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				for(GraphNode n : computeNextArrayList(i, visited))
					if(!tmpNext.contains(n))
						tmpNext.add(n);
			next = tmpNext;

			return nextArrayList();
		}

		public GraphNode normalise() {
			Set<GraphNode> visited = new HashSet<GraphNode>();
			ArrayList<GraphNode> alist = new ArrayList<GraphNode>();
			for(GraphNode n: next)
				if(!this.equals(n))
					alist.addAll(n.normalise(visited));
			next = alist;
			return hasLoopNode() ? normalise() : this;
		}

		/***********************************************************/
		/*               Count EndNodes/Ignore LoopNodes           */
		/***********************************************************/

		//polymorphic on LoopNode, EndNode
		protected int onlyEndNodes(Set<GraphNode> visited) {
			return -1;
		}

		protected int onlyEndNodes() {
			return onlyEndNodes(new HashSet<GraphNode>());
		}

		//polymorphic on PlugNode
		protected boolean isPlugged() {
			return isPlugged(new HashSet<GraphNode>());
		}

		protected boolean isPlugged(Set<GraphNode> visited) {
			if(visited.contains(this))
				return false;

			visited.add(this);

			for(GraphNode n: next)
				if(n.isPlugged(visited))
					return true;

			return false;
		}

		/***********************************************************/
		/*               Clone Graphs			           */
		/***********************************************************/

		abstract protected GraphNode cloneNode();

		protected GraphNode cloneGraph(GraphNode end) {
			return cloneGraph(end, new HashMap<GraphNode, GraphNode>());
		}

		//Polymorphic on LoopNode
		protected GraphNode cloneGraph(GraphNode end, Map<GraphNode, GraphNode> visited) {
			if(visited.get(this) != null)
				return visited.get(this);

			GraphNode r = cloneNode();
			visited.put(this, r);

			for(GraphNode n: next)
				r.addNext(n.cloneGraph(end, visited));

			return r;
		}

		protected GraphNode plugGraph() {
			return plugGraph(new HashMap<GraphNode, GraphNode>());
		}

		//Polymorphic on PlugNode
		protected GraphNode plugGraph(Map<GraphNode, GraphNode> visited) {
			if(visited.get(this) != null)
				return visited.get(this);

			GraphNode r = cloneNode();
			visited.put(this, r);

			for(GraphNode n: next)
				r.addNext(n.plugGraph(visited));

			return r;
		}

		/***********************************************************/
		/*                For Debug                                */
		/***********************************************************/

		private void printPaths(String s, Set<GraphNode> visited) {
			if((next.size() == 0) || isNodeVisited(visited)) {
				System.out.println(s + toString());
				return;
			}

			for(int i = 0; i < next.size(); i++)
				next.get(i).printPaths(s + toString(), visited);

			removeVisited(visited);
		}

		public void printPaths() {
			Set<GraphNode> s = new HashSet<GraphNode>();
			printPaths("", s);
		}
	}

	/********************************************************************************/
	/*                       Graph Nodes                                            */ 
	/********************************************************************************/

	/*
	 * MethodNode inherits GraphNode
	 * Instantiates a class that represents a method call.
	 */
	public class MethodNode extends GraphNode {
		public MethodNode(String id, TypeDecl[] parameters) {
			super(id, parameters);
		}

		public String toString() {
			return super.toString() + ";";
		}

		protected boolean equalNode(GraphNode n) {
			if(!(n instanceof MethodNode))
				return false;

			if(!n.getId().equals(getId()) || n.getParameters().length != getParameters().length)
				return false;

			for(int i = 0; i < n.getParameters().length; i++) {
				TypeDecl t = n.getParameters()[i];//.getTypeAccess().lookupType();
				//null type should not be matched with primitive type
				//noname type should be matched with any type
				//t can never be instanceof NullType
				//overriden equals(Object o) method
				if(!getParameters()[i].equals(t) && !(t instanceof NoNameType))
					return false;
			}

			return true;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			return equalNode(n) ? super.includes(n, ts) : false;
		}

		protected GraphNode cloneNode() {
			return new MethodNode(getId(), getParameters());
		}
	}

	public class SwitchCase extends GraphNode {
		public SwitchCase(String id) {
			super(id, null);
		}

		public String toString() {
			return getId() + ":";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if((n instanceof SwitchCase) && getId().equals(n.getId()))
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new SwitchCase(getId());
		}
	}

	/*
	 * SwitchNode inherits GraphNode.
	 * Instantiates a class that represents a state where
	 * the continuing state is depended on the result
	 * of the previous method call.
	 */
	public class SwitchNode extends GraphNode {
		public SwitchNode() {
			super(null, null);
		}

		public String toString() {
			return "";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof SwitchNode) 
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new SwitchNode();
		}
	}
	
	/*
	 * LoopNode inherits GraphNode.
	 * Auxiliary Node for creating a typestate graph
	 * Represents a state where there is a possible recursion.
	 */
	public class LoopNode extends GraphNode {
		public LoopNode() {
			super(null, null);
		}

		public String toString() { 
			return "Loop Node;";
		}

		protected boolean __hasLoopNode(Set<GraphNode> visited) {
			return true;
		}

		protected ArrayList<GraphNode> nextArrayList() {
			return next;
		}

		protected ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visited) {
			return (!this.equals(next.get(i))) ? super.computeNextArrayList(i, visited) : new ArrayList<GraphNode>();
		}

		protected GraphNode cloneNode() {
			return new LoopNode();
		}

		protected GraphNode cloneGraph(GraphNode end, Map<GraphNode, GraphNode> visited) {
			//This means that the graph ends in a LoopNode -> the graph is still incomplete
			if(next.size() == 0)
				return cloneNode().addNext(end);
			return super.cloneGraph(end, visited);
		}

		protected int onlyEndNodes(Set<GraphNode> visited) {
			if(isNodeVisited(visited))
				return 0;

			int sum = 0;
			int result;
			for(GraphNode n: next) {
				result = n.onlyEndNodes(visited);
				if(result == -1)
					return -1;
				sum += result;
			}
			return sum;
		}
	}

	/*
	 * EndNode inherits GraphNode
	 * Represents the final state.
	 */
	public class EndNode extends GraphNode {
		public EndNode() {
			super(null, null);
		}

		public String toString() {
			return "End Node;";
		}

		public GraphNode addNext(GraphNode n) {
			return this;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof EndNode)
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new EndNode();
		}

		protected int onlyEndNodes(Set<GraphNode> visited) {
			return 1;
		}
	}

	/*
	 * InitNode inherits GraphNode
	 * Represents the initial state.
	 */
	public class InitNode extends GraphNode {
		public InitNode() {
			super(null, null);
		}

		public String toString() {
			return "Init Node;";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof InitNode)
				return super.includes(n, ts);
			return false;
		}

		protected GraphNode cloneNode() {
			return new InitNode();
		}
	}

	public class PlugNode extends LoopNode {
		VariableDecl vd;

		public PlugNode(VariableDecl vd) {
			super();
			this.vd = vd;
		}

		public String toString() {
			return "PlugNode";
		}

		protected boolean isPlugged(Set<GraphNode> visited) {
			//this means that if there are next nodes then this is not plugged
			if(next.size() == 0)
				return true;
			return super.isPlugged(visited);
		}

		protected GraphNode plugGraph(Map<GraphNode, GraphNode> visited) {
			return vd.typestate.current.cloneGraph(null);
		}
	}
}
