aspect JavaSemanticCheck {
	//TODO check for no linear expressions in the throw and try stmts??
	//TODO check for calling linear methods on the this keyword (inside linear methods)??
	//TODO how about constructor calls??... no linear calls.

	//TODO check the use of typestate fields in non typestate method

	protected void TypestateClassDecl.semanticCheck() {
		if(!existsTypestateDecl())
			addSemanticError(
				"Cannot find typestate " +
				getTypestateArg().toString() +
				" defined for class " +
				getID() + "."
			);
		//TODO maybe put the next check as a warning
/*		else
			for(TypestateMethod m : getTypestateDecl().getMethods()) {
				if(m.lookupMethod(this) == null)
					addSemanticError(
						"Method with signature " +
						m.signature() +
						" defined in typestate " +
						getTypestateDecl().getID() +
						" is not implemented in class "
						+ getID() +
						"."
					);
			}
*/	}

	protected void VariableDecl.semanticCheck() {
		//TODO A typestate field should not be self-reference ?????
		if(getTypeAccess().lookupType().isTypestateClassDeclType()) {
			if(isField() && !getClassDeclAncestor().isTypestateClassDeclType())
				addSemanticError(
					"Field " +
					getID() +
					" with typestate type " +
					getTypeAccess().toString() +
					" is declared in non-typestate class " +
					getClassDeclAncestor().getID() +
					"."
				);
			if(isField() && !getModifiers().isPrivate())
				addSemanticError(
					"Field " +
					getID() +
					" with typestate type " +
					getTypeAccess().toString() +
					" should be private"
				);
			if(isField() && getModifiers().isStatic())
				addSemanticError(
					"Field " +
					getID() +
					" with typestate type " +
					getTypeAccess().toString() +
					" should not be static."
				);
			if(getNumDims() > 0 || getTypeAccess().hasDims())
				addSemanticError(
					(isField() ? "Field ": "Variable ") +
					getID() + " with typestate type " +
					getTypeAccess().toString() +
					" should not be an array."
				);
		}
	}	

	protected void MethodDecl.semanticCheck() {
		//TODO What if Method is a typestate method and static
		if(getTypeAccess().hasDims() && getTypeAccess().lookupType().isTypestateClassDeclType())
			addSemanticError(
				"Return typestate type " +
				getTypeAccess().toString() +
				" should not be an array."
			);
		//check - if the return type has a typestate then the method should be declared the typestate definition
		if(/*getClassDeclAncestor().isTypestateClassDeclType() && */getTypeAccess().lookupType().isTypestateClassDeclType()) {
			if(!isTypestateMethod())
				addSemanticError(
					signature() + ": Only methods declared in a typestate can return objects with a typestate."
				);
		}

		if(!isTypestateMethod() && !getUsedTypestateFields().isEmpty()) {
			if(!getModifiers().isPrivate())
				addSemanticError(
					signature() + ": Methods that are not defined in the typestate and use typestate fields should be private."
				);
		}
	}

	protected void ParameterDeclaration.semanticCheck() {
		if(getTypeAccess().hasDims() && getTypeAccess().lookupType().isTypestateClassDeclType())
			addSemanticError(
				"Parameter " +
				getID() + 
				" with typestate type " +
				getTypeAccess().toString() +
				" should not be an array."
			);
	}

	protected void MethodAccess.semanticCheck() {
		if(getQualifiedType().isTypestateClassDeclType()) {
			//TODO if at least one method in the list is a typestatemethod
			ArrayList<MethodDecl> a = lookupMethodTargets(getQualifiedType());
			if(a.size() == 0)
				addSemanticError("Method call " + signature() + " has no target.");
			else if(a.size() > 1) {
				String s = "";
				for(int i = 0; i < a.size(); i++) {
					if(i != 0)
						s += ", ";
					s += ((MethodDecl) a.get(i)).signature();
				}
				addSemanticError("Method call " + signature() + " has conflicting targets: " + s + ".");
			}
		}

		if(isThisAccess()) {
			MethodDecl md = lookupMethod(getQualifiedType());	//TODO what if md == null
			if(md != null && !md.getUsedTypestateFields().isEmpty() && !getMethodDeclAncestor().isTypestateMethod())
				addSemanticError(
					"Cannot call a method that uses typestate fields inside a method that is not defined in the typestate."
				);
		}
	}

	protected void ClassInstanceExpr.semanticCheck() {
		if(getAccess().lookupType().isEnumDeclType()) {
			EnumDecl e = getAccess().lookupType().getEnumDecl();
			if(!e.getEnums().contains(getArg(0).toString()))
				addSemanticError("Argument for enumeration instance creation should have type: " + e.getID() + ".");
		}
	}

	protected void SwitchStmt.semanticCheck() {
		if(getExpr().isAccess()) {
			Access a = ((Access)getExpr()).getLastAccess();
			if (a.getQualifiedType().isEnumDeclType()/* && a.toString().equals("getEnum()")*/) {
				EnumDecl e = a.getQualifiedType().getEnumDecl();
				for(String s : e.getEnums())
					if(!getCaseLabels().contains(s))
						addSemanticError("Enumeration type " + s + " should be a switch case.");
				for(String s : getCaseLabels())
					if(!e.getEnums().contains(s))
						addSemanticError("Case " + s.toString() + " should be an enumeration with type: " + e.getID() +".");
			}
		}
	}
	//TODO check assignments (and new variable assigments) or maybe they are ok due to private typestate types
}
