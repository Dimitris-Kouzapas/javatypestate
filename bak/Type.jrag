aspect Type {
	syn lazy CompilationUnit Expr.type();

	//not used
	eq VarAccess.type() = null;
	eq AmbiguousAccess.type() = null;
	eq PackageOrTypeAccess.type() = lookupType(getID());
	eq PackageAccess.type() = lookupType(getPackage());
	//Deprecated
	eq SuperAccess.type() = null;
	//Dont check the source because of null possibility
	eq AssignExpr.type() = getDest().type();
	eq ConditionalExpr.type() = getTrueExpr().type() != null ? getTrueExpr().type() : getFalseExpr().type();
	eq Literal.type() = null;
//	eq NullLiteral.type() = null;			//TODO Is NullLiteral is special?
	eq Binary.type() = getLeftOperand().type() != null ? getLeftOperand().type() : getRightOperand().type();
	eq LogicalExpr.type() = null;
	eq RelationalExpr.type() = null;
	eq Unary.type() = getOperand().type();
	eq InstanceOfExpr.type() = null;
	eq CastExpr.type() = getTypeAccess().type();
	eq ParExpr.type() = getExpr().type();
	eq ArrayInit.type() {
		for(int i = 0; i < getNumInit(); i++) 
			if(getInit(i).type() != null)
				return getInit(i).type();
		return  null;
	}
	eq ClassAccess.type() = null;
	eq ClassInstanceExpr.type() = getAccess().type();
	eq ArrayCreationExpr.type() = getTypeAccess().type();
	//case of super class is deprecated
	eq ConstructorAccess.type() = (getID().equals("this")) ? getCompilationUnitParent() : null;
	eq ThisAccess.type() = getCompilationUnitParent();
	//TODO is static search needed here?
	eq ParseName.type() = lookupVariable() != null ? lookupType(lookupVariable().getTypeAccess().typeAccessID()) : null; //lookupType(getID());
	eq ArrayAccess.type() = null;
	eq TypeAccess.type() = null;
	eq ArrayTypeAccess.type() = getAccess().type();
	eq ArrayTypeWithSizeAccess.type() = getAccess().type();
	eq MethodAccess.type() = lookupMethodType();
	eq AbstractDot.type() {
		CompilationUnit u = getLeft().type();
		String pre = getLeft().qualifiedString("");
		return getRight().type(u, pre);
	}

	syn CompilationUnit Access.type(CompilationUnit u, String pre) = null;
	eq AbstractDot.type(CompilationUnit u, String pre) {
		CompilationUnit cu = getLeft().qualifiedType(u, pre);
		String tmp = getLeft().qualifiedString(pre);
		return getRight().type(cu, tmp);
	}
	eq ParseName.type(CompilationUnit u, String pre) {
		VariableDeclaration vd = lookupVariable(u);
		//TODO Dont need the static here??
		return (vd != null) ? lookupType(vd.getTypeAccess().typeAccessID()) : null;
	}
	eq MethodAccess.type(CompilationUnit u, String pre) = u != null ? lookupMethodType(u) : null;
	eq ThisAccess.type(CompilationUnit u, String pre) = u;
	eq ArrayAccess.type(CompilationUnit u, String pre) = u;
	eq ConstructorAccess.type(CompilationUnit u, String pre) = type();
	eq ClassInstanceExpr.type(CompilationUnit u, String pre) = type();	//TODO I dont know if it is correct.

	/*****************************************************************/
	/*                 AbstractDot Left Expression                   */
	/*****************************************************************/


	syn CompilationUnit Expr.qualifiedType(CompilationUnit u, String pre) = null;
	eq ParseName.qualifiedType(CompilationUnit u, String pre) {
		VariableDeclaration vd = lookupVariable(u);
		if(vd != null)
			return lookupType(vd.getTypeAccess().typeAccessID());
		else
			return (pre != null) ? lookupType(pre + "." + getID()) : null;
	}
	eq MethodAccess.qualifiedType(CompilationUnit u, String pre) = (u != null) ? lookupMethodType(u) : null;
	eq ThisAccess.qualifiedType(CompilationUnit u, String pre) = u;
	eq ArrayAccess.qualifiedType(CompilationUnit u, String pre) = u;
	eq ConstructorAccess.qualifiedType(CompilationUnit u, String pre) = type();
	eq ClassInstanceExpr.qualifiedType(CompilationUnit u, String pre) = type();			//TODO I dont know if it is correct.

	syn String Expr.qualifiedString(String pre) = null;
	eq ParseName.qualifiedString(String pre) {
		if(pre == null)
			return null;
		if(pre.equals(""))
			return getID();
		return pre + "." + getID();
	}
//	eq ThisAccess.qualifiedString(String pre) = pre;		//TODO This is wrong
	eq ArrayAccess.qualifiedString(String pre) = pre;
	eq AbstractDot.qualifiedString(String pre) = getRight().qualifiedString(getLeft().qualifiedString(pre));
//	syn lazy String AbstractDot.qualifiedString() = getRight().qualifiedString(getLeft().qualifiedString(""));
	syn lazy String Expr.qualifiedString() = qualifiedString("");
//	eq ArrayTypeAccess.qualifiedString(String prev) = getAccess().qualifiedString(prev);
//	eq ArrayTypeWithSizeAccess.qualifiedString(String prev) = getAccess().qualifiedString(prev);
//	eq ClassInstanceExpr.qualifiedString(String pre) = null;			//TODO I dont know 

	/*****************************************************************/
	/*                          TypeID                               */
	/*****************************************************************/

	syn lazy String Expr.typeID();
	syn lazy String Access.typeID();
	//not used
	eq VarAccess.typeID() = null;
	eq AmbiguousAccess.typeID() = null;
	eq PackageOrTypeAccess.typeID() = getID();
	eq PackageAccess.typeID() = getPackage();
	//Deprecated
	eq SuperAccess.typeID() = null;
	//Dont check the source because of null possibility
	eq AssignExpr.typeID() = getDest().typeID();
	eq ConditionalExpr.typeID() = getTrueExpr().typeID() != null ? getTrueExpr().typeID() : getFalseExpr().typeID();
	eq Literal.typeID() = null;
	eq BooleanLiteral.typeID() = "boolean";
	eq CharacterLiteral.typeID() = "char";
	eq StringLiteral.typeID() = "String";
	eq NullLiteral.typeID() = null;
	eq IntegerLiteral.typeID() = "int";
	eq LongLiteral.typeID() = "long";
	eq FloatingPointLiteral.typeID() = "float";
	eq DoubleLiteral.typeID() = "double";
	eq Binary.typeID() = getLeftOperand().typeID() != null ? getLeftOperand().typeID() : getRightOperand().typeID(); //TODO casting??
	eq LogicalExpr.typeID() = "boolean";
	eq RelationalExpr.typeID() = "boolean";
	eq Unary.typeID() = getOperand().typeID();
	eq InstanceOfExpr.typeID() = "boolean";
	eq CastExpr.typeID() = getTypeAccess().typeID();
	eq ParExpr.typeID() = getExpr().typeID();
	eq ArrayInit.typeID() {
		for(int i = 0; i < getNumInit(); i++) 
			if(getInit(i).typeID() != null)
				return getInit(i).typeID();
		return  null;
	}
	eq ClassAccess.typeID() = "Class";
	eq ClassInstanceExpr.typeID() = getAccess().typeID();
	eq ArrayCreationExpr.typeID() = getTypeAccess().typeID();
	//case of super class is deprecated
	eq ConstructorAccess.typeID() = (getID().equals("this")) ? classID() : null;
	eq ThisAccess.typeID() = classID();
	eq ParseName.typeID() {
		if(lookupVariable() != null)
			return lookupVariable().getTypeAccess().toString();
		//TODO recheck for static names
//		else if(lookupType(getID() != null)
//			return getID();
		return null;
	}
	eq ArrayAccess.typeID() = null;
	eq TypeAccess.typeID() = getID();					//TODO TypeAccess is used as a name as well.
	eq ArrayTypeAccess.typeID() = getAccess().typeID() + "[]";
	eq ArrayTypeWithSizeAccess.typeID() = getAccess().typeID() + "[]";
	eq MethodAccess.typeID() = lookupMethod() != null ? lookupMethod().typeID() : null;


	eq AbstractDot.typeID() {
		CompilationUnit u = getLeft().type();
		String pre = getLeft().qualifiedString("");
		return getRight().typeID(u, pre);
	}

	syn String Expr.typeID(CompilationUnit u, String pre) = null;
	eq ParseName.typeID(CompilationUnit u, String pre) {			//TODO static class names?? Needed for resolving method argument types
		VariableDeclaration vd = lookupVariable(u);
		return (vd != null) ? vd.getTypeAccess().toString() : null; 
	}
	eq MethodAccess.typeID(CompilationUnit u, String pre) = u != null ? typeID(u) : null;	//TODO is there an improvement?
	eq ThisAccess.typeID(CompilationUnit u, String pre) = pre;				//TODO this is wrong
	eq ArrayAccess.typeID(CompilationUnit u, String pre) = pre;
	eq TypeAccess.typeID(CompilationUnit u, String pre) = getID();
	eq ClassAccess.typeID(CompilationUnit u, String pre) = "Class";
	eq ArrayTypeAccess.typeID(CompilationUnit u, String pre) = getAccess().typeID(u, pre) + "[]";
	eq ArrayTypeWithSizeAccess.typeID(CompilationUnit u, String pre) = getAccess().typeID(u, pre) + "[]";
	eq ConstructorAccess.typeID(CompilationUnit u, String pre) = typeID();
	eq ClassInstanceExpr.typeID(CompilationUnit u, String pre) = typeID();			//TODO I dont know if it is correct.
	eq AbstractDot.typeID(CompilationUnit u, String pre) {
		CompilationUnit cu = getLeft().qualifiedType(u, pre);
		String tmp = getLeft().qualifiedString(pre);
		return getRight().typeID(u, tmp);
	}

	/***********************************************************/
	/*                   Method Access                         */
	/***********************************************************/

	syn lazy ArrayList<MethodDecl> Expr.getMethodDeclarations() = null;
	syn lazy ArrayList<MethodDecl> MethodAccess.getMethodDeclarations() = 
							isTypestateMethod() ? getMethodDeclarations(getID(), getParameterTypes()) : null;
	eq AbstractDot.getMethodDeclarations() {
		String pre = getLeft().qualifiedString("");
		return (getLeft().getMethodDeclarations() != null) ?	getLeft().getMethodDeclarations() :
									getRight().getMethodDeclarations(getLeft().type(), pre);
	}

	syn ArrayList<MethodDecl> Expr.getMethodDeclarations(CompilationUnit u, String pre) = null;
	eq AbstractDot.getMethodDeclarations(CompilationUnit u, String pre) {
		ArrayList<MethodDecl> al = getLeft().getMethodDeclarations(u, pre);
		CompilationUnit cu = getLeft().qualifiedType(u, pre);
		String tmp = getLeft().qualifiedString(pre);
		return (al != null) ? al : getRight().getMethodDeclarations(cu, tmp);
	}

	eq MethodAccess.getMethodDeclarations(CompilationUnit u, String pre) {
		if(u == null)
			return null;
		ArrayList<MethodDecl> s = u.getMethodDeclarations(getID(), getParameterTypes());
		for(int i = 0; i < s.size(); i++) {
			if(s.get(i).isTypestateMethod())
				return s;
		}
		return null;
	}
}
