aspect graphStructures {
	// Class GraphNode represents a node in the graph structure that
	// represents a typestate type.
	// **
	// The class is abstract and it is inherited by classes:
	// - MethodNode:	represents a state where a method call should be done.
	// - LoopNode:		a node representing a state where you can choose on a set of continuations.
	// - SwithNode:		represents a state where a method call must be done and depending
	//			on the method call return value the state proceeds accordingly.
	// - EmptyNode:		Used for building the Graph.
	// **
	// The class is equipped with methods for:
	// - Traversing a graph:
	// - Checking equality between graphs.
	// - Normalise a graph by removing all empty nodes.
	// - Check if a graph has empty/loop nodes.

	//TODO consider overiding equals
	abstract class GraphNode {
		private String signature;
		protected ArrayList<GraphNode> next;

		protected GraphNode(String m) {
			signature = m;
			next = new ArrayList<GraphNode>();
		}

		public String toString() {
			return signature != null ? signature : "";
		}

		public String signature() {
			return signature;
		}

		public GraphNode addNext(GraphNode n) {
			if(n != null)
				next.add(n);
			return this;
		}

		/**********************************************************/
		/*                Equivalence relations                   */
		/**********************************************************/

		//Create a structure to store tuples (doubles) of GraphNode elements
		//Tuples construct a closure of GraphNode to co-inductively check that two nodes were
		//revisited at the same time by the "includes" algorithm.
		protected class TupleSet {
			Set<GraphNode> list1, list2;

			public TupleSet() {
				list1 = new HashSet<GraphNode>();
				list2 = new HashSet<GraphNode>();
			}

			//TODO is this correct? Maybe has(n1, n2) should check for existense of n1, n2 at the same index of each list
			public boolean has(GraphNode n1, GraphNode n2) {
				return list1.contains(n1) && list2.contains(n2);
			}

			public void insert(GraphNode n1, GraphNode n2) {
				list1.add(n1);
				list2.add(n2);
			}

			public void remove(GraphNode n1, GraphNode n2) {
				list1.remove(n1);
				list2.remove(n2);
			}
		}

		private boolean hasNext() {
			return next.size() != 0;
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(ts.has(this, n) || (!hasNext() && !n.hasNext()))
				return true;

			ts.insert(this, n);
			for(int i = 0; i < n.next.size(); i++) {
				boolean b = false;
				for(int j = 0; j < next.size(); j++)
					if(b |= next.get(j).includes(n.next.get(i), ts))
						break;

				if(b == false) {
					ts.remove(this, n);
					return false;
				}
			}
			return true;
		}

		protected boolean includes(GraphNode n) {
			return includes(n, new TupleSet());
		}

		/**************************************************************/
		/*                     Normalise Graph                        */
		/**************************************************************/

		protected boolean isNodeVisited(Set<GraphNode> visitedSet) {
			if(visitedSet.contains(this))
				return true;
			visitedSet.add(this);
			return false;
		}

		protected void removeVisited(Set<GraphNode> visitedSet) {
			visitedSet.remove(this);
		}

		//Polymorphic on LoopNode
		protected ArrayList<GraphNode> nextArrayList() {
			ArrayList<GraphNode> a = new ArrayList<GraphNode>();
			a.add(this);
			return a;
		}

		//Polymorphic on SwitchNode, LoopNode
		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return next.get(i).normalise(visitedSet);
		}

		//Remove LoopNodes. Polymorphic on SwitchNode
		protected ArrayList<GraphNode> normalise(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return nextArrayList();

			ArrayList<GraphNode> tmpNext = new ArrayList<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				tmpNext.addAll(computeNextArrayList(i, visitedSet));
			next = tmpNext;		//TODO This is a bit of a problem on Loop Nodes??

			return nextArrayList();
		}

		//Polymorphic in Switch
		protected boolean equalNode(GraphNode n) {
			return signature.equals(n.signature());
		}

		private boolean isNormalised(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return true;

			for(int i = 0; i < next.size(); i++)
				for(int j = i + 1; j < next.size(); j++)
					if(next.get(i).equalNode(next.get(j)))
						return false;

			for(int i = 0; i < next.size(); i++)
				if(!next.get(i).isNormalised(visitedSet))
					return false;
			return true;
		}

		protected boolean isNormalised() {
			return isNormalised(new HashSet<GraphNode>());
		}

		//Polymorphic on LoopNode
		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			if(isNodeVisited(visitedSet))
				return false;
			for(int i = 0; i < next.size(); i++)
				if(next.get(i).__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		private boolean hasLoopNode() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				if(next.get(i).__hasLoopNode(visitedSet))
					return true;
			return false;
		}

		protected GraphNode normalise() {
			Set<GraphNode> visitedSet = new HashSet<GraphNode>();
			ArrayList<GraphNode> alist = new ArrayList<GraphNode>();
			for(int i = 0; i < next.size(); i++)
				if(!this.equals(next.get(i)))
					alist.addAll(next.get(i).normalise(visitedSet));
			next = alist;
			return hasLoopNode() ? normalise() : this;
		}

		/***********************************************************/
		/*                For Debug                                */
		/***********************************************************/

		//Polymorphic on SwitchNode. Adds switch case
		protected void setSwitchCase(int i){
		}

		private void printPaths(String s, Set<GraphNode> visitedSet) {
			if((next.size() == 0) || isNodeVisited(visitedSet)) {
				System.out.println(s + toString());
				return;
			}
			for(int i = 0; i < next.size(); i++) {
				setSwitchCase(i);
				next.get(i).printPaths(s + toString(), visitedSet);
			}
			removeVisited(visitedSet);
		}

		public void printPaths() {
			Set<GraphNode> s = new HashSet<GraphNode>();
			printPaths("", s);
		}
	}

	// MethodNode inherits GraphNode
	// It instantiates a class that represents the state where
	// method call needs to be done in the typestate type.
	public class MethodNode extends GraphNode {
		public MethodNode(String m) {
			super(m);
		}

		public String toString() {
			return super.toString() + ";";
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof MethodNode)
				return toString().equals(n.toString()) ? super.includes(n, ts) : false;
			return false;
		}
	}

	// SwitchNode inherits GraphNode
	// It instantiates a class that represents a state where
	// a method call needs to be done and the continuing state
	// is depended on the result of the method call.
	public class SwitchNode extends GraphNode {
		private String scase;
		private ArrayList<String> expr;

		public SwitchNode(String m) {
			super(m);
			scase = null;
			expr = new ArrayList<String>();
		}

		public GraphNode addNext(GraphNode n) {
			return addNext(n, null);
		}

		public GraphNode addNext(GraphNode n, String e) {
			super.addNext(n);
			if(n != null)
				expr.add(e);
			return this;
		}

		public String toString() {
			return super.toString() + ((scase != null) ? " " + scase + ":" : ";");
		}

		protected void setSwitchCase(int i){
			scase = expr.get(i);
		}

		static private ArrayList<String> tmpExpr; //Used in computeNextArray
		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			if(i == 0)
				 tmpExpr = new ArrayList<String>();
			ArrayList<GraphNode> alist = next.get(i).normalise(visitedSet);
			for(int j = 0; j < alist.size(); j++)
				tmpExpr.add(expr.get(i));
			if(i == next.size())
				expr = tmpExpr;
			return alist;
		}

		protected boolean equalNode(GraphNode n) {
			SwitchNode sn = (SwitchNode) n;
				for(int i = 0; i < sn.expr.size(); i++)
					if(!(expr.contains(sn.expr.get(i))))
						return false;
			return signature().equals(n.signature());
		}

		protected boolean includes(GraphNode n, TupleSet ts) {
			if(n instanceof SwitchNode)
				return equalNode(n) ? super.includes(n, ts) : false;
			return false;
		}
	}

	//LoopNode inherits GraphNode.
	// It represents a state where there is a recursion on the typestate type.
	public class LoopNode extends GraphNode {
		public LoopNode(String m) {
			super(m);
		}

		public LoopNode() {
			super(null);
		}

		public String toString() { 
			return "Label " + super.toString() + ":";
		}

		protected boolean __hasLoopNode(Set<GraphNode> visitedSet) {
			return true;
		}

		protected ArrayList<GraphNode> nextArrayList() {
			return next;
		}

		ArrayList<GraphNode> computeNextArrayList(int i, Set<GraphNode> visitedSet) {
			return (!this.equals(next.get(i))) ? next.get(i).normalise(visitedSet) : new ArrayList<GraphNode>();
		}
	}

	// EndNode inherits GraphNode
	// Auxiliary Class used to build a typestate type.
	public class EndNode extends GraphNode {
		protected EndNode() {
			super(null);
		}

		public String toString() {
			return "End Node;";
		}
	}

	public class InitNode extends GraphNode {
		protected InitNode() {
			super(null);
		}

		public String toString() {
			return "Init Node;";
		}
	}

	class TypestateGraph {
		public GraphNode main;
		//Use this to avoid circular calls
		public HashMap<TypestateFunc, GraphNode> tfuncs;

		public TypestateGraph() {
			main = null;
			tfuncs = new HashMap<TypestateFunc, GraphNode>();
		}

		//TODO for debug

		void print() {
			main.printPaths();
			GraphNode n = main.normalise();
			System.out.println("\n\n");
			n.printPaths();
		}

		void debugCompare(TypestateGraph gt) {
			GraphNode n1 = main.normalise();
			GraphNode n2 = gt.main.normalise();
			n1.printPaths();
			System.out.println("\n");
			n2.printPaths();
			System.out.println("\n");

			System.out.println(n1.includes(n2));
		}
	}

	class NameStructure {

		public class NodeWrap {
			NodeWrap(GraphNode s) {
				start = s;
			}
			GraphNode start;
		}

		private String name;
		private ArrayList<NodeWrap> graph;
		private ArrayList<NodeWrap> errorGraph;
		private NodeWrap argumentGraph;
		private NodeWrap asgnWrap;

		NameStructure(String n) {
			name = new String(n);
			graph = new ArrayList<NodeWrap>();
			errorGraph = new ArrayList<NodeWrap>();
			asgnWrap = null;
			argumentGraph = new NodeWrap(new LoopNode());
		}

		String name() {
			return name;
		}

		NodeWrap setAssignWrap(NodeWrap aw) {
			return asgnWrap = aw;
		}

		NodeWrap setAssignWrap() {
			return asgnWrap = new NodeWrap(null);
		}

		NodeWrap addNameStructure(GraphNode startNode) {
			NodeWrap nw = null;

			if(asgnWrap != null) {
				asgnWrap.start = startNode;
				nw = asgnWrap;
				asgnWrap = null;
			}
			else
				nw = new NodeWrap(startNode);

			graph.add(nw);
			return nw;
		}

		NodeWrap addNameStructure(NodeWrap nw) {
			if(asgnWrap != null) {			//TODO is this check correct?? May not needed
				asgnWrap.start = nw.start;
				nw = asgnWrap;
				asgnWrap = null;
			}
			graph.add(nw);
			return nw;
		}

		NodeWrap setArgumentGraph(GraphNode start) {
			argumentGraph.start.addNext(start);
			return argumentGraph;
		}

		GraphNode argumentGraph() {
			return argumentGraph.start;
		}

		void addErrorGraph(GraphNode startNode) {
			errorGraph.add(new NodeWrap(startNode));
		}

		public ArrayList<GraphNode> graph() {
			return graph(graph);
		}

		public ArrayList<GraphNode> errorGraph() {
			return graph(errorGraph);
		}

		private ArrayList<GraphNode> graph(ArrayList<NodeWrap> g) {
			ArrayList<GraphNode> a = new ArrayList<GraphNode>();
			for(int i = 0; i < g.size(); i++)
				a.add(g.get(i).start.normalise());		//TODO this normalise might cause problems
			return a;
		}
	}
}
