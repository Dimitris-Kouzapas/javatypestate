import java.io.PrintStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.lang.StringBuffer;

/* This aspect deals with the PrettyPrinting of the Java Typestate
 * programs. It makes the nessecary syntax rewriting to Java syntax
 * so the javac compiler can accept and compile the program.
*/

aspect Rewrite {

	public class MyOutputStream {
		// This class is used to create an output File Writer
		// for transforming the JavaTypestate code to Java Code
		private String path;
		private PrintStream myStream;
		private StringBuffer sb;
		private PrintStream out;

		private int indent;		/*Indent counts the number of indentations*/
		private String indentString;
		private boolean changeLine;

		/* The next three methods are used for 
		 * controlling indentation
		*/
		public void pushIndent() {
			indent++;
			createIndentString();
		}
		public void popIndent() {
			indent--;
			createIndentString();
		}

		private void createIndentString() {
			indentString = "";
			for(int i = 0; i < indent; i++)
				indentString = indentString + "\t";
		}

		public MyOutputStream() {
			path = null;
			out = null;
			sb = new StringBuffer();
			indent = 0;
			changeLine = true;
			createIndentString();
		}

		public MyOutputStream(String path) throws FileNotFoundException {
			this();
			myStream = new PrintStream(path);
			this.path = new String(path);
		}

		public MyOutputStream(String path, PrintStream out) throws FileNotFoundException {
			this(path);
			this.out = out;
		}

		public MyOutputStream(PrintStream out) {
			this();
			this.out = out;
		}

		public void println() {
			if (myStream != null)
				myStream.println();
			if(out != null)
				out.println();
			sb.append("\n");
			changeLine = true;
		}

		public void println(String s) {
			String is = (changeLine == true) ? indentString : "";
			if (myStream != null)
				myStream.println(is + s);
			if(out != null)
				out.println(is + s);
			sb.append(is + s + "\n");	
			changeLine = true;
		}

		public void print(String s) {
			String is = (changeLine == true) ? indentString : "";
			if (myStream != null)
				myStream.print(is + s);
			if(out != null)
				out.print(is + s);
			sb.append(is + s);
			changeLine = false;
		}

		public void reset() {
			sb = new StringBuffer();
			path = null;
			out = null;
		}

		public void close() {
			if (myStream != null)
				myStream.close();
		}

		public String toString() {
			return sb.toString();
		}

	}

	protected static MyOutputStream ASTNode.stream = new MyOutputStream();
	protected static MyOutputStream ASTNode.stream() {
		return stream;
	}
	protected static void ASTNode.setStream(MyOutputStream s) {
		stream = s;
	}
	protected static void ASTNode.setStream(PrintStream p) {
		stream = new MyOutputStream(p);
	}
	protected static void ASTNode.setStream(String path, PrintStream p) {
		try {
			stream = new MyOutputStream(path, p);
		}
		catch(FileNotFoundException e) {
			System.err.println("Could not open file: " + path + " for writing");
			e.printStackTrace();
			System.exit(-1);
		}
	}
	protected static void ASTNode.setStream(String path) {
		try {
			stream = new MyOutputStream(path);
		}
		catch(FileNotFoundException e) {
			System.err.println("Could not open file: " + path + " for writing");
			e.printStackTrace();
			System.exit(-1);
		}
	}

	protected void ASTNode.Rewrite() {}

	protected void Expr.Rewrite() {}

	protected void Dims.Rewrite() {
		stream().print("[");
		if(hasExpr())
			getExpr().Rewrite();
		stream().print("]");
	}

	syn String Unary.getOp() = "";
	syn String PreIncExpr.getOp() = "++";
	syn String PreDecExpr.getOp() = "--";
	syn String MinusExpr.getOp() = "+";
	syn String PlusExpr.getOp() = "-";
	syn String BitNotExpr.getOp() = "~";
	syn String LogNotExpr.getOp() = "!";

	protected void CastExpr.Rewrite() {
		stream().print("(");
		getTypeAccess().Rewrite();
		stream().print(") ");
		getExpr().Rewrite();
	}

	protected void Unary.Rewrite() {
		stream().print(getOp());
		getOperand().Rewrite();
	}

	syn String PostfixExpr.getOp() = "";
	syn String PostIncExpr.getOp() = "++";
	syn String PostDecExpr.getOp() = "--";

	protected void PostfixExpr.Rewrite() {
		getOperand().Rewrite();
		stream().print(getOp());
	}

	syn String AssignExpr.getOp() = "";
	syn String AssignSimpleExpr.getOp() = "=";
	syn String AssignMulExpr.getOp() = "*=";
	syn String AssignDivExpr.getOp() = "/=";
	syn String AssignModExpr.getOp() = "%=";
	syn String AssignPlusExpr.getOp() = "+=";
	syn String AssignMinusExpr.getOp() = "-=";
	syn String AssignLShiftExpr.getOp() = "<<=";
	syn String AssignRShiftExpr.getOp() = ">>=";
	syn String AssignURShiftExpr.getOp() = ">>>=";
	syn String AssignAndExpr.getOp() = "&=";
	syn String AssignXorExpr.getOp() = "^=";
	syn String AssignOrExpr.getOp() = "|=";

	protected void AssignExpr.Rewrite() {
		getDest().Rewrite();
		stream().print(" " + getOp() + " ");
		getSource().Rewrite();
	}

	protected void Binary.Rewrite() {
		getLeftOperand().Rewrite();
		stream().print(" " + getOp() +" ");
		getRightOperand().Rewrite();
	}

	syn String Binary.getOp() = "";
	syn String MulExpr.getOp() = "*";
	syn String DivExpr.getOp() = "/";
	syn String ModExpr.getOp() = "%";

	syn String AddExpr.getOp() = "+";
	syn String SubExpr.getOp() = "-";

	syn String LShiftExpr.getOp() = "<<";
	syn String RShiftExpr.getOp() = ">>";
	syn String URShiftExpr.getOp() = ">>>";

	syn String AndBitwiseExpr.getOp() = "&";
	syn String OrBitwiseExpr.getOp() = "|";
	syn String XorBitwiseExpr.getOp() = "^";

	syn String AndLogicalExpr.getOp() = "&&";
	syn String OrLogicalExpr.getOp() = "||";

	syn String LTExpr.getOp() = "<";
	syn String GTExpr.getOp() = ">";
	syn String LEExpr.getOp() = "<=";
	syn String GEExpr.getOp() = ">=";

	syn String EQExpr.getOp() = "==";
	syn String NEExpr.getOp() = "!=";

	protected void InstanceOfExpr.Rewrite() {
		getExpr().Rewrite();
		stream().print(" instanceof ");
		getTypeAccess().Rewrite();
	}

	protected void ConditionalExpr.Rewrite() {
		getCondition().Rewrite();
		stream().print(" ? ");
		getTrueExpr().Rewrite();
		stream().print(" : ");
		getFalseExpr().Rewrite();
	}

	protected void Literal.Rewrite() {
		stream().print(getLITERAL());
	}

	protected void StringLiteral.Rewrite() {
		stream().print("\"" + getLITERAL() + "\"");
	}

	protected void CharacterLiteral.Rewrite() {
		stream().print("\'" + getLITERAL() + "\'");
	}

	protected void ArrayInit.Rewrite(){
		stream().print("{");
		for(int i = 0; i < getNumInit(); i++) {
			if(i != 0)
				stream().print(", ");
			getInit(i).Rewrite();
		}
		stream().print("}");
	}

	protected void ClassInstanceExpr.Rewrite() {
		stream().print("new ");
		getAccess().Rewrite();
		stream().print("(");
		for(int i = 0; i < getNumArg(); i++)
			getArg(i).Rewrite();
		stream().print(")");
		//Deprecated
		if(hasTypeDecl())
			getTypeDecl().Rewrite();
	}

	protected void ArrayCreationExpr.Rewrite() {
		stream().print("new ");
		getTypeAccess().Rewrite();
		if(hasArrayInit())
			getArrayInit().Rewrite();
	}

	protected void Access.Rewrite() {}

	protected void ParseName.Rewrite() {
		stream().print(getID());
	}

	protected void Dot.Rewrite() {
		getLeft().Rewrite();
		stream().print(".");
		getRight().Rewrite();
	}

	protected void PrimitiveTypeAccess.Rewrite() {
		stream().print(getName());
	}

	protected void ArrayAccess.Rewrite() {
		stream().print("[");
		getExpr().Rewrite();
		stream().print("]");
	}

	protected void ArrayTypeWithSizeAccess.Rewrite() {
		getAccess().Rewrite();
		stream().print("[");
		getExpr().Rewrite();
		stream().print("]");
	}

	protected void ArrayTypeAccess.Rewrite() {
		getAccess().Rewrite();
		stream().print("[]");
	}

	protected void ClassAccess.Rewrite() {
		stream().print("class");
	}

	protected void ThisAccess.Rewrite() {
		stream().print("this");
	}

	//Deprecated
	protected void SuperAccess.Rewrite() {
		stream().print("super");
	}

	protected void MethodAccess.Rewrite() {
		stream().print(getID() + "(");
		for(int i = 0; i < getNumArg(); i++) {
			if(i != 0)
				stream().print(", ");
			getArg(i).Rewrite();
		}
		stream().print(")");
	}

	protected void ParExpr.Rewrite() {
		stream().print("(");
		getExpr().Rewrite();
		stream().print(")");
	}

	//protected void SuperConstructorAccess.Rewrite(){} inherits from
	//ConstructorAccess.Rewrite()
	protected void ConstructorAccess.Rewrite(){
		stream().print(getID() + "(");
		for(int i = 0; i < getNumArg(); i++) {
			if (i != 0)
				stream().print(", ");
			getArg(i).Rewrite();
		}
		stream().print(")");
	}

	protected void ParameterDeclaration.Rewrite() {
		getModifiers().Rewrite();
		getTypeAccess().Rewrite();
		stream().print(" " + getID());
	}

	protected void ImportDecl.Rewrite() {}

	protected void SingleTypeImportDecl.Rewrite() {
		stream().print("import ");
		getAccess().Rewrite();
		stream().println(";");
	}

	protected void TypeImportOnDemandDecl.Rewrite() {
		stream().print("import ");
		getAccess().Rewrite();
		stream().println(".*;");
	}

	protected void Modifiers.Rewrite() {
		for(int i = 0; i < getNumModifier(); i++)
			getModifier(i).Rewrite();
	}

	protected void Modifier.Rewrite() {
		stream().print(getID()+ " ");
	}

	protected void VariableDecl.Rewrite() {
		stream().print(getID());
		for(int i = 0; i < getNumDims(); i++)
			getDims(i).Rewrite();

		if(hasInit()) {
			stream().print(" = ");
			getInit().Rewrite();
		}
	}

	protected void Stmt.Rewrite() {}
	protected void Stmt.RewriteNoSemicolon() {}

	protected void ExprStmt.Rewrite() {
		getExpr().Rewrite();
		stream().println(";");
	}

	protected void ExprStmt.RewriteNoSemicolon() {
		getExpr().Rewrite();
	}

	protected void VarDeclStmt.Rewrite() {
		RewriteNoSemicolon();
		stream().println(";");
	}

	protected void VarDeclStmt.RewriteNoSemicolon() {
		getModifiers().Rewrite();
		getTypeAccess().Rewrite();
		stream().print(" ");
		for(int i = 0; i < getNumVariableDecl(); i++) {
			if (i != 0)
				stream().print(", ");
			getVariableDecl(i).Rewrite();
		}
	}

	protected void IfStmt.Rewrite() {
		stream().print("if(");
		getCondition().Rewrite();
		stream().print(") ");
		getThen().Rewrite();
		if(hasElse()) {
			stream().print("else ");
			getElse().Rewrite();
		}
	}
	protected void ForStmt.Rewrite() {
		stream().print("for(");
		for(int i = 0; i < getNumInitStmt(); i++) {
			if(i != 0)
				stream().print(", ");
				getInitStmt(i).RewriteNoSemicolon();
		}
		stream().print("; ");
		getCondition().Rewrite();
		stream().print("; ");
		for(int i = 0; i < getNumUpdateStmt(); i++) {
			if(i != 0)
				stream().print(", ");
			getUpdateStmt(i).RewriteNoSemicolon(); 
		}
		stream().print(") ");
		getStmt().Rewrite();
			
	}

	protected void SwitchStmt.Rewrite() {
		stream().print("switch(");
		getExpr().Rewrite();
		stream().print(")");
		getBlock().Rewrite();
	}

	protected void ConstCase.Rewrite() {
		stream().print("case ");
		getValue().Rewrite();
		stream().println(":");
	}

	protected void DefaultCase.Rewrite() {
		stream().println("default:");
	}

	protected void WhileStmt.Rewrite() {
		stream().print("while(");
		getCondition().Rewrite();
		stream().print(") ");
		getStmt().Rewrite();
	}

	protected void DoStmt.Rewrite() {
		stream().print("do ");
		getStmt().Rewrite();
		stream().print("while(");
		getCondition().Rewrite();
		stream().println(");");
	}

	protected void LabeledStmt.Rewrite() {
		stream().println(getLabel() + ":");
		getStmt().Rewrite();
	}

	protected void EmptyStmt.Rewrite() {
		stream().println(";");
	}

	protected void BreakStmt.Rewrite() {
		if(getLabel().equals(""))
			stream().println("break;");
		else
			stream().println("break " + getLabel() + ";");
	}

	protected void ContinueStmt.Rewrite() {
		if(getLabel().equals(""))
			stream().println("continue;");
		else
			stream().println("continue " + getLabel() + ";");
	}

	protected void ReturnStmt.Rewrite() {
		if(!hasResult())
			stream().println("return;");
		else {
			stream().print("return ");
			getResult().Rewrite();
			stream().println(";");
		}
	}

	protected void ThrowStmt.Rewrite() {
		stream().print("throw ");
		getExpr().Rewrite();
		stream().println(";");
	}

	protected void TryStmt.Rewrite() {
		stream().print("try ");
		getBlock().Rewrite();
		for(int i = 0; i < getNumCatchClause(); i ++)
			getCatchClause(i).Rewrite();
		if(hasFinally()) {
			stream().print("finally ");
			getFinally().Rewrite();
		}
	}

	protected void AssertStmt.Rewrite() {
		stream().print("assert ");
		getfirst().Rewrite();
		if(hasExpr()) {
			stream().print(" : ");
			getExpr().Rewrite();
		}
		stream().println(";");
	}

	protected void CatchClause.Rewrite() {}
	protected void BasicCatch.Rewrite() {
		stream().print("(");
		getParameter().Rewrite();
		stream().print(") ");
		getBlock().Rewrite();
	}

	protected void Block.Rewrite() {
		stream().println("{");
		stream().pushIndent();
		for(int i = 0; i < getNumStmt(); i++)
			getStmt(i).Rewrite();
		stream().popIndent();
		stream().println("}");
	}

	protected void BodyDecl.Rewrite() {}

	protected void MethodDecl.Rewrite() {
		getModifiers().Rewrite();
		getTypeAccess().Rewrite();
		stream().print(" " + getID() + "(");
		for(int i = 0; i < getNumParameter(); i++) {
			if (i != 0)
				stream().print(", ");
			getParameter(i).Rewrite();
		}
		stream().print(")");
		if(getNumException() > 0) {
			stream().print(" throws ");
		}
		for(int i = 0; i < getNumException(); i++) {
			if(i != 0)
				stream().print(", ");
			getException(i).Rewrite();
		}
		stream().print(" ");
		if(hasBlock())
			getBlock().Rewrite();
		else
			stream().println(";");
	}

	protected void ConstructorDecl.Rewrite() {
		getModifiers().Rewrite();
		stream().print(getID() + "(");
		for(int i = 0; i < getNumParameter(); i++) {
			if (i != 0)
				stream().print(", ");
			getParameter(i).Rewrite();
		}
		stream().print(")");
		if(getNumException() > 0) {
			stream().print(" throws ");
		}
		for(int i = 0; i < getNumException(); i++) {
			if(i != 0)
				stream().print(", ");
			getException(i).Rewrite();
		}
		stream().println("{");
		stream().pushIndent();
		if(hasConstructorInvocation())
			getConstructorInvocation().Rewrite();
		//not invoking Block.Rewrite due to the {}
		Block b = getBlock();
		for(int i = 0; i < b.getNumStmt(); i++)
			b.getStmt(i).Rewrite();
		stream().popIndent();
		stream().println("}");
		
	}
	protected void FieldDecl.Rewrite() {
		getModifiers().Rewrite();
		getTypeAccess().Rewrite();
		stream().print(" ");
		for(int i = 0; i < getNumVariableDecl(); i++) {
			if (i != 0)
				stream().print(", ");
			getVariableDecl(i).Rewrite();
		}
		stream().println(";");
	}

	protected void InstanceInitializer.Rewrite() {
		if(getBlock().getNumStmt() > 0)
			getBlock().Rewrite();		//Deprecated
		else
			stream().println(";");
	}

	protected void StaticInitializer.Rewrite() {
		if(getBlock().getNumStmt() > 0)
			getBlock().Rewrite();		//Deprecated
		else
			stream().println(";");
	}

	protected void TypeDecl.Rewrite(){}

	//Deprecated
	protected void InterfaceDecl.Rewrite() {
		getModifiers().Rewrite();
		stream().print("interface " + getID() + " ");
		if (getNumSuperInterfaceId() > 0) {
			stream().print("extends ");
		}
		for(int i = 0; i < getNumSuperInterfaceId(); i++) {
			if (i != 0)
				stream().print(", ");
			getSuperInterfaceId(i).Rewrite();
		}
		stream().println(" {");
		stream().pushIndent();
		//TODO: Typestate print
		for(int i = 0; i < getNumBodyDecl(); i++)
			getBodyDecl(i).Rewrite();
		stream().popIndent();
		stream().println("}");
	}

	protected void ClassDecl.Rewrite() {
		getModifiers().Rewrite();
		stream().print("class " + getID() + " ");
		if (hasSuperClassAccess()) {			//Deprecated
			stream().print("extends " );
			getSuperClassAccess().Rewrite();
			stream().print(" ");
		}
		if (getNumImplements() > 0) {			//Deprecated
			stream().print("implements ");
		}
		for(int i = 0; i < getNumImplements(); i++) {	//Deprecated
			if (i != 0)
				stream().print(", ");
			getImplements(i).Rewrite();
		}

		stream().println(" {");
		stream().pushIndent();
		//TODO: Typestate print
		for(int i = 0; i < getNumBodyDecl(); i++)
			getBodyDecl(i).Rewrite();
		stream().popIndent();
		stream().println("}");
	}

	protected void CompilationUnit.Rewrite() {
		if(!getPackageDecl().equals(""))
			stream().println("package " + getPackageDecl() + ";");

		for(int i = 0; i < getNumImportDecl(); i++)
			getImportDecl(i).Rewrite();

		getTypeDecl().Rewrite();
	}

	protected void Program.Rewrite() {
		for(int i = 0; i < getNumCompilationUnit(); i++)
			getCompilationUnit(i).Rewrite();		
	}

	/************************************************************/
	/*                   Program Interface                      */
	/************************************************************/

	public void Program.debug(PrintStream ps) {
		MyOutputStream os = stream();
		setStream(ps);
		Rewrite();
		setStream(os);
	}

	public ArrayList<String> Program.Transform() {
		MyOutputStream os = stream();
		ArrayList<String> a = new ArrayList<String>();
		for(int i = 0; i < getNumCompilationUnit(); i++) {
			CompilationUnit u = getCompilationUnit(i);
			if (!u.isTypestateUnit()) {
				setStream(u.dirPath + u.getTypeDecl().getID() + ".java");
				a.add(u.dirPath + u.getTypeDecl().getID() + ".java");
				u.Rewrite();
				stream().close();
			}
//			else {
//				;//TODO rewrite the typestate to a java program
//			}
		}
		setStream(os);
		return a;
	}
	/************************************************************/
	/*                        Typestate                         */
	/************************************************************/

	//TODO: Decide from Reachable/Unreachable code
	protected void TypestateDecl.Rewrite() {
		for(int i = 0; i < getNumTypestateFunc(); i++) {
			if(getTypestateFunc(i).isReachable()) {
				if(i != 0)
					stream().println();
				getTypestateFunc(i).Rewrite();
			}
		}
	}

	protected void TypestateFunc.Rewrite() {
		stream().println(getID() + " {");
		getTypestate().Rewrite();
		stream().println("}");
	}

	protected void Typestate.Rewrite() {
		stream().pushIndent();
		for(int i = 0; i < getNumTypestateBlock(); i++)
			getTypestateBlock(i).Rewrite();

		stream().popIndent();
	}
	protected void TypestateBlock.Rewrite() { }

	protected void MethodTBlock.RewriteNoNewLine() {
		gettype().getAccess().Rewrite();
		stream().print(" " + getID() + "(");
		for(int i = 0; i < getNumMyType(); i++) {
			if (i != 0) 
				stream().print(", ");
			getMyType(i).getAccess().Rewrite();
		}
		stream().print(")");
	}

	protected void MethodTBlock.Rewrite() {
		RewriteNoNewLine();
		stream().println(";");
	}

	protected void WhileTBlock.Rewrite() {
		stream().println("while {");
		getTypestate().Rewrite();
		stream().println("}");
	}

	protected void EitherTBlock.Rewrite() {
		stream().println("either {");
		for(int i = 0; i < getNumTypestate(); i++) {
			if (i != 0)
				stream().print(", ");
			getTypestate(i).Rewrite();
		}
		stream().println("}");
	}

	protected void LabelTBlock.Rewrite() {
		stream().println(getID() + ";");
	}

	protected void SwitchTBlock.Rewrite() {
		stream().print("switch (");
		getMethod().RewriteNoNewLine();
		stream().println(") {");
		stream().pushIndent();
		for(int i = 0; i < getNumConstantTypestate(); i++) {
			if (i != 0)
				stream().println(", ");
			getConstantTypestate(i).Rewrite();
		}
		stream().popIndent();
		stream().println("}");
	}

	protected void ConstantTypestate.Rewrite() {
		stream().print("(");
		getExpr().Rewrite();
		stream().println("):");
		getTypestate().Rewrite();
	}

	/************************************************************/
	/*                       toString()                         */
	/************************************************************/

	//One toString fits All
	public String ASTNode.toString() {
		stream().reset();
		Rewrite();
		return stream().toString();
	}

	//Type IDs don't use array dimensions
	syn String Access.typeAccessID() = toString();
	eq ArrayTypeAccess.typeAccessID() = getAccess().typeAccessID();
//	eq ArrayTypeWithSizeAccess.typeID() = getAccess().typeID();	//inherits toString from ArrayTypeAccess
	syn String MethodDecl.typeAccessID() = getTypeAccess().typeAccessID();

	syn String MethodDecl.typeID() = getTypeAccess().toString();

	syn lazy String MethodDecl.signature() {
		//Dont really need getModifiers().Rewrite();
		String s = getTypeAccess().toString() + " " + getID() + "(";
		for(int i = 0; i < getNumParameter(); i++) {
			if (i != 0)
				s += ", ";
			s += getParameter(i).getTypeAccess().toString();
		}
		return s + ")";
	}

	syn lazy String MethodTBlock.signature() {
		stream().reset();
		RewriteNoNewLine();
		return stream().toString();
	}
}
