//The program semantic checker represents typestates as graphs
//This aspect implements the functionality of creating and handling typestate graphs.

aspect graphTypestate {

	syn lazy TypestateGraph TypeDecl.createTypestateGraph() = null;

	/*********************************************************/
	/*                 Typestate Graph                       */
	/*********************************************************/

	private TypestateGraph TypestateDecl.graph = null;

	eq TypestateDecl.createTypestateGraph() {
		if(graph == null)
			graph = new TypestateGraph();

		graph.main = new LoopNode(getMainLabel());
		//To avoid circular call of createGraphNode() for main
		graph.tfuncs.put(getMain(), graph.main);
		graph.main.addNext(getMain().createGraphNode());
		graph.main = new InitNode().addNext(graph.main);
		graph.main.normalise();
		return graph;
	}

	//implements getGraphNode in LabelTBlock
	eq TypestateDecl.getTypestateFunc(int i).getGraphNode(TypestateFunc tf) {
		GraphNode n;
		if(!graph.tfuncs.containsKey(tf)) {
			n =new LoopNode(tf.getID());
			//To avoid circular call of createGraphNode() for tf
			graph.tfuncs.put(tf, n);
			n.addNext(tf.createGraphNode());
		}
		else
			n = graph.tfuncs.get(tf);
		return n;
	}

	syn lazy GraphNode TypestateFunc.createGraphNode() {
		return getTypestate().createGraphNode(new EndNode());
	}

	syn GraphNode Typestate.createGraphNode(GraphNode end) {
		for(int i = getNumTypestateBlock() - 1; i >= 0; i--)
			end = getTypestateBlock(i).createGraphNode(end);
		return end;
	}

	syn GraphNode TypestateBlock.createGraphNode(GraphNode end) = null;

	eq MethodTBlock.createGraphNode(GraphNode end) {
		return new MethodNode(signature()).addNext(end);
	}

	eq EitherTBlock.createGraphNode(GraphNode end) {
		GraphNode gn = new LoopNode();
		for(int i = 0; i < getNumTypestate(); i++)
			gn.addNext(getTypestate(i).createGraphNode(end));
		return gn;
	}

	eq WhileTBlock.createGraphNode(GraphNode end) {
		GraphNode gn = new LoopNode();
		gn.addNext(getTypestate().createGraphNode(gn));
		return gn.addNext(end);
	}

	syn Typestate SwitchTBlock.getTypestate(int i) = getConstantTypestate(i).getTypestate();
	syn String SwitchTBlock.getExprString(int i) = getConstantTypestate(i).getExpr().toString();

	eq SwitchTBlock.createGraphNode(GraphNode end) {
		SwitchNode gn = new SwitchNode(getMethod().signature()); 
		for(int i = 0; i < getNumConstantTypestate(); i++)
			gn.addNext(getTypestate(i).createGraphNode(end), getExprString(i));
		return gn;
	}

	inh GraphNode LabelTBlock.getGraphNode(TypestateFunc tf);
	syn lazy GraphNode LabelTBlock.getGraphNode() = getGraphNode(getTarget());
	eq LabelTBlock.createGraphNode(GraphNode end) {
		return getGraphNode();
	}


	/*********************************************************/
	/*                    Class Graph                        */
	/*********************************************************/

	//TODO implement me
	eq ClassDecl.createTypestateGraph() {
		return null;
	}

	syn GraphNode Stmt.createGraphNode(NameStructure name, GraphNode end);
	eq Block.createGraphNode(NameStructure name, GraphNode end) {
		if(!getLocalVariableIDs().contains(name))
			for(int i = getNumStmt() - 1; i >= 0; i--)
				end = getStmt(i).createGraphNode(name, end);
		return end;
	}

	//Not used classes
	eq VariableDeclaration.createGraphNode(NameStructure name, GraphNode end) = end;
	eq SynchronizedStmt.createGraphNode(NameStructure name, GraphNode end) = end;
	eq LocalClassDeclStmt.createGraphNode(NameStructure name, GraphNode end) = end;
	//Not typestate classes
	eq ConstCase.createGraphNode(NameStructure name, GraphNode end) = end;
	eq DefaultCase.createGraphNode(NameStructure name, GraphNode end) = end;
	eq EmptyStmt.createGraphNode(NameStructure name, GraphNode end) = end;

	//Try and Throw are not supposed to use linear expressions
	eq ThrowStmt.createGraphNode(NameStructure name, GraphNode end) = end;
	eq TryStmt.createGraphNode(NameStructure name, GraphNode end) = end;

	inh GraphNode BreakStmt.getTargetEndNode();	//Implemented in loop Stmts
	inh GraphNode BreakStmt.getTargetEndNode(String label);	//Implemented in labelledStmt
	eq BreakStmt.createGraphNode(NameStructure name, GraphNode end) =
							getLabel().equals("") ? getTargetEndNode() : getTargetEndNode(getLabel());

	inh GraphNode ContinueStmt.getTargetStartNode();		//Implemented in loop Stmts
	inh GraphNode ContinueStmt.getTargetStartNode(String label);	//Implemented in labelledStmt
	eq ContinueStmt.createGraphNode(NameStructure name, GraphNode end) =
							getLabel().equals("") ? getTargetStartNode() : getTargetStartNode(getLabel());

	eq TypeDecl.getBodyDecl(int i).getTargetEndNode() = null;
	eq TypeDecl.getBodyDecl(int i).getTargetStartNode() = null;

	eq ReturnStmt.createGraphNode(NameStructure name, GraphNode end) {
		//TODO if result is name then mark name in method and endNode should not be end node
		GraphNode e = new EndNode();
		return hasResult() ? getResult().createGraphNode(name, e) : e;
	}
	//No need to handle second expression
	eq AssertStmt.createGraphNode(NameStructure name, GraphNode end) = getfirst().createGraphNode(name, end);
	eq ExprStmt.createGraphNode(NameStructure name, GraphNode end) = getExpr().createGraphNode(name, end);

	inh GraphNode LabeledStmt.getTargetEndNode(String label);
	inh GraphNode LabeledStmt.getTargetStartNode(String label);

	eq LabeledStmt.getStmt().getTargetEndNode(String label) = label.equals(getLabel()) ? endNode : getTargetEndNode(label);
	eq LabeledStmt.getStmt().getTargetStartNode(String label) = label.equals(getLabel()) ? startNode : getTargetStartNode(label);

	eq LabeledStmt.createGraphNode(NameStructure name, GraphNode end) {
		startNode = new LoopNode();
		endNode = end;
		startNode.addNext(getStmt().createGraphNode(name, endNode));
		return startNode;
	}

	eq TypeDecl.getBodyDecl(int i).getTargetEndNode(String label) = null;
	eq TypeDecl.getBodyDecl(int i).getTargetStartNode(String label) = null;

	//TODO IfStmt has issues with non-determinism
	eq IfStmt.createGraphNode(NameStructure name, GraphNode end) {
		LoopNode c = new LoopNode();
		c.addNext(getThen().createGraphNode(name, end));
		if(hasElse())
			c.addNext(getElse().createGraphNode(name, end));
		else
			c.addNext(end);
		return getCondition().createGraphNode(name, c);
	}

	//Next two are used for break and continue statements
	protected GraphNode BranchTargetStmt.endNode = null;
	protected GraphNode BranchTargetStmt.startNode = null;

	//Implements in BreakStmt, ContinueStmt
	eq WhileStmt.getStmt().getTargetEndNode() = endNode;
	eq WhileStmt.getStmt().getTargetStartNode() = startNode;

	//TODO WhileStmt has issues with non-determinism
	eq WhileStmt.createGraphNode(NameStructure name, GraphNode end) {
		endNode = end;
		startNode = new LoopNode();
		LoopNode c = new LoopNode();
		c.addNext(getStmt().createGraphNode(name, startNode));
		c.addNext(endNode);
		GraphNode n = getCondition().createGraphNode(name, c);
		startNode.addNext(n);
		return n;
	}

	//Implements in BreakStmt, ContinueStmt
	eq ForStmt.getStmt().getTargetEndNode() = endNode;
	eq ForStmt.getStmt().getTargetStartNode() = startNode;

	//TODO ForStmt has issues with non-determinism
	eq ForStmt.createGraphNode(NameStructure name, GraphNode end) {
		startNode = new LoopNode();
		endNode = end;
		GraphNode n = startNode;
		for(int i = getNumUpdateStmt() - 1; i >= 0; i--)
			n = getUpdateStmt(i).createGraphNode(name, n);

		n = getStmt().createGraphNode(name, n);
		LoopNode c = new LoopNode();
		c.addNext(n);
		c.addNext(endNode);

		if(hasCondition())
			n = getCondition().createGraphNode(name, c);
		else
			n = c;

		for(int i = getNumInitStmt() - 1; i >= 0; i--)
			n = getInitStmt(i).createGraphNode(name, n);

		startNode.addNext(n);
		return startNode;
	}

	eq DoStmt.getStmt().getTargetEndNode() = endNode;
	eq DoStmt.getStmt().getTargetStartNode() = startNode;

	//TODO DoStmt has issues with non-determinism
	eq DoStmt.createGraphNode(NameStructure name, GraphNode end) {
		startNode = new LoopNode();
		endNode = end;

		LoopNode c = new LoopNode();
		c.addNext(startNode);
		c.addNext(endNode);

		GraphNode n = getCondition().createGraphNode(name, c);
		return getStmt().createGraphNode(name, n);
	}

	eq SwitchStmt.getBlock().getTargetEndNode() = endNode;

	//TODO recheck
	eq SwitchStmt.createGraphNode(NameStructure name, GraphNode end) {
		endNode = end;
		GraphNode m = getExpr().createGraphNode(name, null); //TODO this is wrong... should check for a single method call
		Block b = getBlock();
		GraphNode n = end;
		if(m != null) {
			ArrayList<String> count = new ArrayList<String>();
			SwitchNode sn = new SwitchNode(m.signature());
			for(int i = b.getNumStmt() - 1; i >= 0; i--) {
				if(!(b.getStmt(i) instanceof Case)) {
					for(int j = 0; j < count.size(); j++)
						sn.addNext(n, count.get(j));
					count.clear();
					n = b.getStmt(i).createGraphNode(name, n);
				}
				else if(b.getStmt(i) instanceof ConstCase)
					count.add(((ConstCase)b.getStmt(i)).getValue().toString());
				else if(b.getStmt(i) instanceof DefaultCase)
					count.add("default");
			}
			for(int j = 0; j < count.size(); j++)
				sn.addNext(n, count.get(j));
			return sn;
		}
		else {
			LoopNode sn = new LoopNode();
			boolean c = false;
			for(int i = b.getNumStmt() - 1; i >= 0; i--) {
				if(!(b.getStmt(i) instanceof Case)) {
					if(c == true)
						sn.addNext(n);
					c = false;
					n = b.getStmt(i).createGraphNode(name, n);
				}
				else
					c = true;
			}
			if(c == true)
				sn.addNext(n);
			return sn;
		}
	}

	eq VarDeclStmt.createGraphNode(NameStructure name, GraphNode end) {
		for(int i = getNumVariableDecl() - 1; i >= 0; i--)
			end = getVariableDecl(i).createGraphNode(name, end);
		return end;
	}

	/***************************************************************************************************************/

	syn GraphNode Expr.createGraphNode(NameStructure name, GraphNode end);

	NameStructure.NodeWrap VariableDecl.startNode = null;
	private GraphNode VariableDecl.endNode = null;

	//TODO just recheck
	syn GraphNode VariableDecl.createGraphNode(NameStructure name, GraphNode end) {
		if(hasInit()) {
			if(getInit().qualifiedString() != null && getInit().qualifiedString().equals(name.name())) {
				if(!(end instanceof EndNode))
					name.addErrorGraph(end);

				end = new LoopNode();
				if(endNode == null) {
					endNode = end;
					startNode = name.setAssignWrap();
				}
				else {
					endNode = end.addNext(endNode);
					name.setAssignWrap(startNode);
				}
			}

			if(getID().equals(name.name())) {
				if(getInit() instanceof ClassInstanceExpr) {			//TODO method calls
					name.addNameStructure(new InitNode().addNext(end));
					return new EndNode();
				}
//				else if {
//					methodAccess case
//				}
				else {
					if(endNode == null) {
						endNode = end;
						startNode = name.addNameStructure((GraphNode) null);
					}
					else {
						endNode.addNext(end);
						name.addNameStructure(startNode);
					}
				}
			}
		}
		return hasInit() ? getInit().createGraphNode(name, end) : end;
	}

	NameStructure.NodeWrap AssignExpr.startNode = null;
	private GraphNode AssignExpr.endNode = null;

	//TODO just recheck
	eq AssignExpr.createGraphNode(NameStructure name, GraphNode end) {
		if(getSource().qualifiedString() != null && getSource().qualifiedString().equals(name.name())) {
			if(!(end instanceof EndNode))
				name.addErrorGraph(end);

			end = new LoopNode();
			if(endNode == null) {
				endNode = end;
				startNode = name.setAssignWrap();
			}
			else {
				endNode = end.addNext(endNode);
				name.setAssignWrap(startNode);
			}
		}

		if(getDest().qualifiedString() != null && getDest().qualifiedString().equals(name.name())) {	//TODO method calls
			if(getSource() instanceof ClassInstanceExpr)
				name.addNameStructure(new InitNode().addNext(end));

//			else if(getSource() is MethodAccess) {
//				lookupMethod()...
//				return new EndNode();
//			}
			else {
				if(endNode == null) {
					endNode = end;
					startNode = name.addNameStructure((GraphNode) null);
				}
				else {
					endNode.addNext(end);
					name.addNameStructure(startNode);
				}
			}

			return new EndNode();
			
		}
		GraphNode n = getSource().createGraphNode(name, end);
		return getDest().createGraphNode(name, n);
	}

	syn GraphNode MethodAccess.createArgsGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		GraphNode n = end;
		for(int i = getNumArg() - 1; i >= 0; i--)
			n = getArg(i).createGraphNode(name, n);

		for(int i = getNumArg() - 1; i >= 0; i--) {
			if(getArg(i).qualifiedString() != null && getArg(i).qualifiedString().equals(name.name()) ) {
				if(!(n instanceof EndNode)) {
					name.addErrorGraph(n);
					n = new EndNode();
				}
				MethodDecl m = lookupMethod(u);
				n = m.getGraphNode(m.getParameter(i)/*.getID()*/);
			}
		}
		return n;
	}



	/***************************************************************************************************************/

	//Not used
	eq AmbiguousAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq VarAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq SuperAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq PackageOrTypeAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq PackageAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq Literal.createGraphNode(NameStructure name, GraphNode end) = end;

	eq Binary.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = getRightOperand().createGraphNode(name, end);
		return getLeftOperand().createGraphNode(name, n);
	}

	//TODO issues with non-determinism
	eq LogicalExpr.createGraphNode(NameStructure name, GraphNode end) {
		LoopNode c = new LoopNode();
		c.addNext(getRightOperand().createGraphNode(name, end));
		c.addNext(end);
		return getLeftOperand().createGraphNode(name, end);
	}

	eq ParExpr.createGraphNode(NameStructure name, GraphNode end) = getExpr().createGraphNode(name, end);

	//TODO issues with non-determinism
	eq ConditionalExpr.createGraphNode(NameStructure name, GraphNode end) {
		LoopNode c = new LoopNode();
		c.addNext(getTrueExpr().createGraphNode(name, end));
		c.addNext(getFalseExpr().createGraphNode(name, end));
		return getCondition().createGraphNode(name, c);
	}

	eq InstanceOfExpr.createGraphNode(NameStructure name, GraphNode end) = getExpr().createGraphNode(name, end);
	//TODO does cast has any weird handling??
	eq CastExpr.createGraphNode(NameStructure name, GraphNode end) = getExpr().createGraphNode(name, end);
	eq Unary.createGraphNode(NameStructure name, GraphNode end) = getOperand().createGraphNode(name, end);

	eq ConstructorAccess.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = end;
		for(int i = getNumArg() - 1; i >= 0; i--)
			n = getArg(i).createGraphNode(name, n);
		return n;
	}

	eq ArrayInit.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = end;
		for(int i = getNumInit() - 1; i >= 0; i--)
			n = getInit(i).createGraphNode(name, n);
		return n;
	}

	eq ArrayCreationExpr.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = end;
		if(hasArrayInit())
			n = getArrayInit().createGraphNode(name, n);
		return n;
	}	

	eq ParseName.createGraphNode(NameStructure name, GraphNode end) = end;
	eq ThisAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq TypeAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	eq ClassAccess.createGraphNode(NameStructure name, GraphNode end) = end;
	//Used when array access is qualified
	eq ArrayAccess.createGraphNode(NameStructure name, GraphNode end) = getExpr().createGraphNode(name, end);
	eq ArrayTypeAccess.createGraphNode(NameStructure name, GraphNode end) = getAccess().createGraphNode(name, end);
	eq ArrayTypeWithSizeAccess.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = getAccess().createGraphNode(name, end);
		return getExpr().createGraphNode(name, n);
	}
	eq ClassInstanceExpr.createGraphNode(NameStructure name, GraphNode end) = end;

	eq MethodAccess.createGraphNode(NameStructure name, GraphNode end) {
		GraphNode n = createArgsGraphNode(getCompilationUnitParent(), name, end);
		if(name.name().equals(""))
			n = createGraphNode(getCompilationUnitParent(), name, n);
		return n;
	}

	syn GraphNode MethodAccess.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		if(u != null && isTypestateMethod(u)) {
			MethodNode m = new MethodNode(signature(u));
			return m.addNext(end);
		}
		return end;
	}

	eq AbstractDot.createGraphNode(NameStructure name, GraphNode end) {
		String pre = getLeft().qualifiedString("");
		end = getRight().createGraphNode(getLeft().type(), pre, name, end);
		return getLeft().createGraphNode(name, end);
	}

	syn GraphNode Expr.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = end;
	eq AbstractDot.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) {
		String tmp = getLeft().qualifiedString(pre);
		CompilationUnit cu = getLeft().qualifiedType(u, pre);
		end = getRight().createGraphNode(cu, tmp, name, end);
		return getLeft().createGraphNode(u, pre, name, end);
	}
//	eq ParseName.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = end;
	eq MethodAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) {
		GraphNode n = createArgsGraphNode(u, name, end);
		return (pre != null && pre.equals(name.name())) ? createGraphNode(u, name, n) : n;
	}
//	eq ThisAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = end;
	eq ArrayAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = createGraphNode(name, end);
	eq ArrayTypeAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) =
										getAccess().createGraphNode(u, pre, name, end);
	eq ArrayTypeWithSizeAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) {
		GraphNode n = getAccess().createGraphNode(u, pre, name, end);
		return getExpr().createGraphNode(u, pre, name, n);
	}
//	eq TypeAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = end;
//	eq ClassAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) = end;
	eq ConstructorAccess.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) =
													createGraphNode(name, end);
	//TODO Is this correct??
	eq ClassInstanceExpr.createGraphNode(CompilationUnit u, String pre, NameStructure name, GraphNode end) =
													createGraphNode(name, end);

	/************************************************************************************************/
	/*                            ClassDecl Typestate                                               */
	/************************************************************************************************/


	//TODO what I do not like is the use of GraphNode attributes in ClassDecl
	syn GraphNode ClassDecl.createGraphNode(GraphNode n, NameStructure name) {
		GraphNode tmp;
		if(n.next.size() != 0)
			tmp = new LoopNode();
		else
			tmp = new EndNode();

		for(int i = 0; i < n.next.size(); i++)
			tmp.addNext(createGraphNode(n.next.get(i), name));

		if(n.signature() != "") //TODO check because it is wrong for LoopNodes
			return getCompilationUnitParent().getMethod(n.signature()).createGraphNode(name, tmp);

		return tmp;
	}

/*
	//TODO not correct at all

//	eq TypestateDecl.createTypestateGraph() {
//		if(graph == null)
//			graph = new TypestateGraph();
//
//		graph.main = new LoopNode(getMainLabel());
//		//To avoid circular call of createGraphNode() for main
//		graph.methods.put(getMainLabel(), graph.main);
//		graph.main.addNext(getMain().createGraphNode());
//		graph.main = new InitNode().addNext(graph.main);
//		graph.main.normalise();
//		return graph;
//	}
//

	TypestateGraph TypestateDecl.g;
	//implements getGraphNode in LabelTBlock
	eq TypestateDecl.getTypestateFunc(int i).getGraphNode(TypestateFunc tf, CompilationUnit u, NameStructure name) {
		GraphNode n;
		if(!g.tfuncs.containsKey(tf)) {
			n =new LoopNode(tf.getID());
			//To avoid circular call of createGraphNode() for tf
			g.tfuncs.put(tf, n);
			n.addNext(tf.createGraphNode());
		}
		else
			n = g.tfuncs.get(tf);
		return n;
	}

	syn lazy GraphNode TypestateFunc.createGraphNode(CompilationUnit u, NameStructure name) {
		return getTypestate().createGraphNode(u, name, new EndNode());
	}

	syn GraphNode Typestate.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		for(int i = getNumTypestateBlock() - 1; i >= 0; i--)
			end = getTypestateBlock(i).createGraphNode(u, name, end);
		return end;
	}

	syn GraphNode TypestateBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) = null;

	eq MethodTBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		return u.getMethod(signature()).createGraphNode(name, end);
		//return new MethodNode(signature()).addNext(end);
	}

	eq EitherTBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		GraphNode gn = new LoopNode();
		for(int i = 0; i < getNumTypestate(); i++)
			gn.addNext(getTypestate(i).createGraphNode(u, name, end));
		return gn;
	}

	eq WhileTBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		GraphNode gn = new LoopNode();
		gn.addNext(getTypestate().createGraphNode(u, name, gn));
		return gn.addNext(end);
	}

//	syn Typestate SwitchTBlock.getTypestate(int i) = getConstantTypestate(i).getTypestate();
//	syn String SwitchTBlock.getExprString(int i) = getConstantTypestate(i).getExpr().toString();

	eq SwitchTBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
		GraphNode n = new LoopNode();
		for(int i = 0; i < getNumConstantTypestate(); i++)
			n.addNext(getTypestate(i).createGraphNode(u, name, end)
			//, getExprString(i)
			);	//TODO is this correct??

		n = u.getMethod(getMethod().signature()).createGraphNode(name, n);
		return n;
	}

	inh GraphNode LabelTBlock.getGraphNode(TypestateFunc tf, CompilationUnit u, NameStructure name);
	syn lazy GraphNode LabelTBlock.getGraphNode(CompilationUnit u, NameStructure name) = getGraphNode(getTarget(), u, name);
	eq LabelTBlock.createGraphNode(CompilationUnit u, NameStructure name, GraphNode end) {
	//	return getTarget().createGraphNode(u, name);
	//	return getGraphNode();
		return getGraphNode(u, name);	
	}

*/
}
