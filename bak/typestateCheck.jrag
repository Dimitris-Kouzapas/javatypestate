aspect typestateCheck {
	//TODO check for no linear expressions in the throw and try stmts
	//TODO check for calling linear methods in linear methods
	//TODO how about constructor calls... no linear calls.

	/**************************************************************************/
	/*                         Typestate  Attributes                          */
	/**************************************************************************/

	syn lazy boolean CompilationUnit.isTypestateUnit() = getTypeDecl() instanceof TypestateDecl;
	syn lazy TypestateDecl CompilationUnit.getTypestate() = getTypeDecl().getTypestate();
	syn lazy boolean CompilationUnit.isTypestate() = getTypeDecl().isTypestate();

	syn lazy CompilationUnit TypeDecl.getTypestateType() = null;
	syn lazy TypestateDecl TypeDecl.getTypestate() = null;
	syn lazy boolean TypeDecl.isTypestate() = false;

	eq ClassDecl.getTypestateType() = hasTypestateArg() ? lookupType(getTypestateArg().typeAccessID()) : null;
	eq ClassDecl.getTypestate() = (TypestateDecl) (getTypestateType() != null ? getTypestateType().getTypeDecl() : null);
	eq ClassDecl.isTypestate() = hasTypestateArg();

	eq TypestateDecl.isTypestate() = true;
	eq TypestateDecl.getTypestate() = this;
	eq TypestateDecl.getTypestateType() = getCompilationUnitParent();

	syn lazy CompilationUnit FieldDecl.type() = lookupType(getTypeAccess().typeAccessID());
	//The next three implement inherited attribute for VariableDecl
	eq FieldDecl.getVariableDecl(int i).getModifiers() = getModifiers();
	eq FieldDecl.getVariableDecl(int i).getTypeAccess() = getTypeAccess();
	eq FieldDecl.getVariableDecl(int i).getTypestate() = type() != null ? type().getTypeDecl().getTypestate() : null;
	eq FieldDecl.getVariableDecl(int i).isTypestate() = type() != null && type().getTypeDecl().isTypestate();
	eq FieldDecl.getVariableDecl(int i).typeAccessID() = getTypeAccess().typeAccessID();
	eq FieldDecl.getVariableDecl(int i).typeID() = getTypeAccess().toString();
	eq FieldDecl.getVariableDecl(int i).isField() = true;
	//The next three implement inherited attribute for VariableDecl.
	syn lazy CompilationUnit VarDeclStmt.type() = lookupType(getTypeAccess().typeAccessID());
	eq VarDeclStmt.getVariableDecl(int i).getModifiers() = getModifiers();
	eq VarDeclStmt.getVariableDecl(int i).getTypeAccess() = getTypeAccess();
	eq VarDeclStmt.getVariableDecl(int i).getTypestate() = type() != null ? type().getTypeDecl().getTypestate() : null;
	eq VarDeclStmt.getVariableDecl(int i).isTypestate() = type() != null && type().getTypeDecl().isTypestate();
	eq VarDeclStmt.getVariableDecl(int i).typeAccessID() = getTypeAccess().typeAccessID();
	eq VarDeclStmt.getVariableDecl(int i).typeID() = getTypeAccess().toString();
	eq VarDeclStmt.getVariableDecl(int i).isField() = false;

	inh Modifiers VariableDecl.getModifiers();
	inh boolean VariableDecl.isTypestate();
	inh TypestateDecl VariableDecl.getTypestate();
	inh Access VariableDecl.getTypeAccess();
	inh String VariableDecl.typeAccessID();
	inh String VariableDecl.typeID();
	inh String VariableDecl.classID();
	inh boolean VariableDecl.isField();

	syn lazy CompilationUnit MethodDecl.type() = lookupType(getTypeAccess().typeAccessID());
	syn lazy boolean MethodDecl.isTypestate() = type() != null && type().getTypeDecl().isTypestate();
	syn lazy boolean MethodDecl.isTypestateMethod() =
				getCompilationUnitParent().getTypestate().getMethodSignatures().contains(signature());

	syn lazy CompilationUnit ParameterDeclaration.type() = lookupType(getTypeAccess().typeAccessID());
	syn lazy boolean ParameterDeclaration.isTypestate() = type() != null && type().getTypeDecl().isTypestate();
	syn lazy int Access.countDims() = 0;
	// ArrayTypeWithSizeAccess inherits
	eq ArrayTypeAccess.countDims() = 1 + getAccess().countDims();
	syn lazy boolean ParameterDeclaration.hasDims() = getTypeAccess().countDims() != 0;

	/**************************************************************************/
	/*                         typestate check                                */
	/**************************************************************************/

	void ASTNode.typestateCheck() {}
	void ASTNode.semanticCheck(){}

	/**************************************************************************/
	/*                         typestate syntax                               */
	/**************************************************************************/
	void TypestateDecl.typestateCheck() {
		if(!isMainDeclared())
			addError("Label \"" + getMainLabel() + "\" is not declared.", TypestateError.ErrorType.SYMBOLNOTFOUND);
	}

	void TypestateDecl.semanticCheck() {
		if(!getProgramParent().hasErrors()) {
			TypestateGraph gt = createTypestateGraph();
			if(!gt.main.isNormalised())
				addError("Typestate " + getID() + " is non-deterministic.", TypestateError.ErrorType.SYMBOLNOTFOUND);
		}
	}

	void TypestateFunc.typestateCheck() {
		if(!isReachable())
			addSemanticError("Label \"" + getID() + "\" is not reachable from " + getMainLabel());
		if(isDuplicate())
			addSemanticError("Duplicate label definition: " + getID());
		
	}

	void TypestateBlock.typestateCheck() {}

	void SwitchTBlock.typestateCheck() {
		ArrayList<Expr> cases = new ArrayList<Expr>();
		for(int i = 0; i < getNumConstantTypestate(); i++)
			cases.add(getConstantTypestate(i).getExpr());
		for(int i = 0; i < cases.size(); i++)
			for(int j = i + 1; j < cases.size(); j++)
				if(cases.get(i).toString().equals(cases.get(j).toString()))
					addError("Duplicated switch label " + cases.get(i) + ".", TypestateError.ErrorType.SYMBOLNOTFOUND);
	}

	void LabelTBlock.typestateCheck() {
		if(getTarget() == null && isReachable())
			addSemanticError("Label \"" + getID() + "\"" + " does not have a target.");
	}

	/**************************************************************************/
	/*                         java syntax                                    */
	/**************************************************************************/


	//TODO Cannot have typestate fields if this is a non typestate class
	void ClassDecl.typestateCheck() {
		analyse();		//TODO this is not the right place for analyse
		if(isTypestate() && !(getTypestate() instanceof TypestateDecl))
			addSemanticError("Cannot find typestate " + getTypestateArg().typeAccessID() + " for class " + getID());

		//TODO Find another way
		if(isTypestate())
			for(Iterator<String> i = getTypestate().getMethodSignatures().iterator(); i.hasNext(); ) {
				String s = i.next();
				if(!getMethodSignatures().contains(s))
					addSemanticError("Method signature \"" + s + "\" declared in typestate \"" + getTypestateArg().typeAccessID() + "\" but not implemented.");
			}
	}

	void ClassDecl.semanticCheck() {
		analyse();
	}

	void VariableDecl.typestateCheck() {
		if(isTypestate()) {
			String s = isField() ? "Field " : "Variable ";
			if(isField() && !getModifiers().isPrivate())
				addSemanticError("Field " + getID() + " with typestate type " + typeAccessID() + " should be private.");
			if(isField() && getModifiers().isStatic())
				addSemanticError("Field " + getID() + " with typestate type " + typeAccessID() + " should be non static.");
			if(getNumDims() != 0)
				addSemanticError(s + getID() + " with typestate type " + typeAccessID() + " should not be array.");
			if(isField() && typeAccessID().equals(classID()))
				addSemanticError("Field " + getID() + " with typestate type " + typeAccessID() + " should not be a self reference field.");
		}

	}

	void MethodDecl.typestateCheck() {
		if(isTypestate())
			addSemanticError("\"" + signature() + "\" Methods cannot return typestate objects.");
		for(int i = 0; i < getNumParameter(); i++)
			if(getParameter(i).isTypestate() && getParameter(i).hasDims())
				addSemanticError("Typestate parameter \"" + getParameter(i).toString() + "\" should not be array");
	}

	//TODO Add more error information
	//TODO check if a method called with typestate arguments can be found
	void MethodAccess.typestateCheck() {
		Access ad = getDotParent();
		if(ad.getMethodDeclarations() != null)
			if(ad.getMethodDeclarations().size() > 1)
				addSemanticError("Method Call \"" + toString() + "\" has conflicting targets.");
	}

	//TODO complete me
	//TODO check for initialisation, check the graph for other errors like linearity of variables
	void Block.typestateCheck() {
		Set<Map.Entry<VariableDecl, NameStructure>> s = variableGraph.entrySet();
		for(Iterator it = s.iterator(); it.hasNext(); ) {
			Map.Entry me = (Map.Entry) it.next();
			VariableDecl var = (VariableDecl) me.getKey();
			NameStructure ng = (NameStructure) me.getValue();
			ArrayList<GraphNode> a = ng.graph();
			TypestateGraph gt = var.getTypestate().createTypestateGraph();
			System.out.println(var.getID());
			for(int j = 0; j < a.size(); j++) {
				System.out.println("----------------------------");
				a.get(j).printPaths();
				System.out.println("----------------------------");
				System.out.println(gt.main.includes(a.get(j)));
			}
			
		}
	}
/*	void Block.typestateCheck() {
		Set<VariableDecl> s = getLocalVariables();
	//	GraphNode n = new EndNode();
		ArrayList<NameGraph> aa = new ArrayList<NameGraph>();
		for(Iterator i = s.iterator(); i.hasNext();) {
			VariableDecl vd = (VariableDecl) i.next();
			if(vd.isTypestate() && vd.getNumDims() == 0) {
				aa.add(analyseVariableGraph(vd.getID()));
			}
		}
		
		System.out.println("*****************************");
		Iterator it = s.iterator();
		for(int i = 0; i < aa.size(); i++) {
			VariableDecl vd;
			do {
				vd = (VariableDecl) it.next();
			} while(!(vd.isTypestate() && vd.getNumDims() == 0));

			ArrayList<GraphNode> a = aa.get(i).graph();
			TypestateGraph gt = vd.getTypestate().createTypestateGraph();
	//		gt.main.printPaths();
	//		System.out.println("\n\n");
			System.out.println(vd.getID());
			for(int j = 0; j < a.size(); j++) {
				System.out.println("----------------------------");
				a.get(j).printPaths();
				System.out.println("----------------------------");
				System.out.println(gt.main.includes(a.get(j)));
			}
		}
		System.out.println("*****************************");
		//TODO check for all variables

	}
*/
}
