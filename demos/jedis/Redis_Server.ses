package demos.jedis;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label. There are three problems.		
		
// 1. At the sender, we have to return as a result the same choice label we were passed as an argument, 
// so that the sender can dispatch on it to continue with the rest of the protocol. But this is weird
// because the sender already knows what choice it made. Nor does it make sense to insist that the
// client specify a continuation for choices it didn't make. If making a choice is calling a method, 
// this problem goes away: every method specifies a state transition already, and if one only calls a 
// single method then one only has to supply a single continuation.     

// 2. We can't at the moment pass arguments along with the label. This is because the sending of the
// label is matched by a receiving of the label on the other side, and receiving occurs by return value.
// Since a Java method can only return a single value, there is no way to pass a payload as well. This
// could be solved within the present approach by splitting every choice into a label send and an
// (optional) payload send. There would then be a question of whether to additionally send a label
// when there is no explicit choice in the original Scribble (i.e. treat every send as preceded by
// an implicit singleton choice). This issue goes away with the choice-as-set-of-methods interpretation.  
			
// 3. There is a "natural" (canonical?) interpretation of a typestate as a Scribble protocol which
// maps available methods to external choice. That mapping doesn't have our translation to typestate
// as its inverse, suggesting that our translation is not the "obvious" one. 

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		Init = {
           String[] receiveWATCH(): Watching
		}
	where
		Watching = {
			WatchingLabel receiveLabel_Watching(): <
				GET_request: Waiting_Watching_GET,
				WATCH: Watching,
				MULTI: Queued
			>
		}

	 	Waiting_Watching_GET = {
			void sendGET_response(String): Watching
	 	}
		
		Queued = {
			QueuedLabel receiveLabel_Queued(): <
		    	SET: Queued,
				DISCARD: end,
				EXEC: Waiting_Queued_EXEC
			>
		}
		
		Waiting_Queued_EXEC = {
			// Here's an example of the need to take a label as argument and then return it.
			ResultLabel sendEXEC_response(int): <
				OK:end, 
				FAIL:Queued
			>
		}
}
