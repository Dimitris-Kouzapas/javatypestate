package demos.jedis;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label. There are three significant problems.		
		
// 1. We have to return as a result the same choice label we were passed as an argument, so that the 
// client can dispatch on it to continue with the rest of the protocol. But this is weird because the
// client already knows what choice it made. Nor does it make sense to insist that the client specify
// a continuation for choices it didn't make. If making a choice is calling a method, this problem
// goes away: every method specifies a state transition already, and if one only calls a single method
// then one only has to supply a single continuation.     

// 2. Since the argument to the chosen branch of the choice currently has to be passed to a single 
// typestate operation, it is forced to be the same for each branch. This is like insisting that all
// methods of an object have the same argument type.
			
// 3. There is a "natural" (canonical?) interpretation of a typestate as a Scribble protocol which
// maps available methods to external choice. That mapping doesn't have our translation to typestate
// as its inverse, suggesting that our translation is not the "obvious" one. 

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		InitSession = {
           void WATCH(String[]): Watching
		}
	where
		Watching = {
			WatchingLabel chooseLabel_Watching(WatchingLabel, String): <
				GET: Waiting_Watching_GET,
				WATCH: Watching,
				MULTI: Queued
			>
		}

	 	Waiting_Watching_GET = {
			void GET(String): Watching
	 	}
		
		Queued = {
			QueuedLabel chooseLabel_Queued(QueuedLabel, String): <
		    	SET: Queued,
				DISCARD: end,
				EXEC: Waiting_Queued_EXEC
			>
		}
		
		Waiting_Queued_EXEC = {
			Result receiveEXEC(): <OK:end, FAIL:Queued>
		}
}
