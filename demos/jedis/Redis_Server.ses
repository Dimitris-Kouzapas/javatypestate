package demos.jedis;

// This is roughly what we would end up with, with our current Scribble-to-typestate translation.
// We can't assume the synchronous "optimisation" here because of the way we translate 
// external choice.

// Currently we represent choice as the explicit sending of a label. Really the label should be 
// construed as the name of a method. There are three significant problems with the status quo.		
		
// 1. We have to return as a result the same choice label we were passed as an argument, so that the 
// client can dispatch on it to continue with the rest of the protocol. But this is weird because the
// client already knows what choice it made. Nor does it make sense to insist that the client specify
// a continuation for choices it didn't make. If making a choice is calling a method, this problem
// does away because every method specifies a state transition already, and if one calls a single
// method then one only has to supply a single continuation.     

// 2. The argument has to be passed to a single operation, and is therefore forced to be the same for 
// all components of the choice.
			
// 3. There is a "natural" (canonical) interpretation of a typestate as a Scribble protocol which
// maps available methods to external choices, but that mapping doesn't have our translation to 
// typestate as its inverse. That suggests our translation is not "natural" (canonical). 

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		InitSession = {
           void WATCH(String[]): Watching
		}
	where
		Watching = {
			WatchingLabel chooseLabel_Watching(WatchingLabel, String): <
				GET_request: Waiting_Watching_GET,
				WATCH: Watching,
				MULTI: Queued
			>
		}

	 	Waiting_Watching_GET = {
			void GET_response(String): Watching
	 	}
		
		Queued = {
			QueuedLabel chooseLabel_Queued(QueuedLabel, String): <
		    	SET: Queued,
				DISCARD: end,
				EXEC: Waiting_Queued_EXEC
			>
		}
		
		Waiting_Queued_EXEC = {
			void EXEC_response_OK(): end,
			void EXEC_response_FAIL: Queued
		}
}
