package demos.jedis;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label. There are three significant problems.		
		
// 1. At the sender, we have to return as a result the same choice label we were passed as an argument, 
// so that the sender can dispatch on it to continue with the rest of the protocol. But this is weird
// because the sender already knows what choice it made. Nor does it make sense to insist that the
// client specify a continuation for choices it didn't make. If making a choice is calling a method, 
// this problem goes away: every method specifies a state transition already, and if one only calls a 
// single method then one only has to supply a single continuation.     

// 2. Since the argument to the chosen branch of the choice currently has to be passed to a single 
// typestate operation, it is forced to be the same for each branch. This is like insisting that all
// methods of an object have the same argument type.
			
// 3. There is a "natural" (canonical?) interpretation of a typestate as a Scribble protocol which
// maps available methods to external choice. That mapping doesn't have our translation to typestate
// as its inverse, suggesting that our translation is not the "obvious" one. 

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		InitSession = {
           String[] receiveWATCH(): Watching
		}
	where
		Watching = {
			WatchingLabel receiveLabel_Watching(String): <
				GET_request: Waiting_Watching_GET,
				WATCH: Watching,
				MULTI: Queued
			>
		}

	 	Waiting_Watching_GET = {
			void sendGET_response(String): Watching
	 	}
		
		Queued = {
			QueuedLabel receiveLabel_Queued(String): <
		    	SET: Queued,
				DISCARD: end,
				EXEC: Waiting_Queued_EXEC
			>
		}
		
		Waiting_Queued_EXEC = {
			// Here's an example of the need to take a label as argument and then return it.
			Result sendEXEC_response(Result): <OK:end, FAIL:Queued>
		}
}
