package demos.jedis;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label, optionally followed by the sending
// of the payload. This is very heavy-handed compared to modelling choice simpy as the invocation
// of a method, but unfortunately that translation to typestate is unable to represent internal
// actions.		
		
// An additional oddity as is that, at the sender, we have to return as a result the same choice label
// we were passed as an argument, so that the sender can dispatch on it to continue with the rest of
// the protocol. But this is weird because the sender already knows what choice it made. Nor does it
// make sense to insist that the client specify a continuation for choices it didn't make.

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		Init = {
           String[] receiveWATCH(): Watching
		}
	where
		Watching = {
			// TODO: augment with argument-passing steps, which requires additional states.
			WatchingLabel receiveLabel_Watching(): <
				GET_request: Waiting_Watching_GET,
				WATCH: Watching,
				MULTI: Queued
			>
		}

	 	Waiting_Watching_GET = {
			void sendGET_response(String): Watching
	 	}
		
		Queued = {
			QueuedLabel receiveLabel_Queued(): <
		    	SET: Queued,
				DISCARD: end,
				EXEC: Waiting_Queued_EXEC
			>
		}
		
		Waiting_Queued_EXEC = {
			// Here's an example of the need to take a label as argument and then return it.
			// Unfortunately our compiler won't less us pass ResultLabel as the type of the
			// label (this problem will go away when we support enums properly).
			ResultLabel sendEXEC_response(int): <
				OK:end, 
				FAIL:Queued
			>
		}
}
