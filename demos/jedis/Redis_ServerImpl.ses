package demos.jedis;

// Dummy implementation, which we can use to illustrate the problem with implementing services.

class Redis_ServerImpl typestate Redis_Server {
    String[] receiveWATCH() {
    	return null;
    }

	WatchingLabel receiveLabel_Watching() {
		return null;
	}

	void sendGET_response(String v) {
	}
		
	QueuedLabel receiveLabel_Queued() {
		return null;
	}
		
	ResultLabel sendEXEC_response(int label) {
		return null;
	}

	// The implementation of all services must be provided essentially inline as straight-line code that
	// waits labels to be received and dispatches on them in order to execute the relevant bit of code.
	
	// We can factor the straight-line code into methods which "manage" the implementation of each
	// service (perhaps this was the "modularity" idea in Gay et al 2010).
	
	public static void main (String[] args) {
		Redis_ServerImpl redis = new Redis_ServerImpl();
		String[] ks = redis.receiveWATCH();
		// add supplied watches
		WATCHING: while (true) {
			// Assume problem with argument passing is fixed somehow.
			switch (redis.receiveLabel_Watching().getEnum()) {
				case WatchingLabel.GET_request:
					redis.sendGET_response("5");
					continue WATCHING;
				case WatchingLabel.WATCH:
					// add more watches
					continue WATCHING;
				case WatchingLabel.MULTI:
					QUEUED: while (true) {
						switch (redis.receiveLabel_Queued().getEnum()) {
							case QueuedLabel.SET:
								// do the set
								continue QUEUED;
							case QueuedLabel.DISCARD:
								break QUEUED;
							case QueuedLabel.EXEC:
								// let's decide to succeed
								switch (redis.sendEXEC_response(ResultLabel.OK).getEnum()) {
									case ResultLabel.OK:
										break QUEUED;
									case ResultLabel.FAIL:
										continue QUEUED;
								}
						}
					}
					break WATCHING;
			}
		}
	}
}
