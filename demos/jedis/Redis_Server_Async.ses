package demos.jedis;

// To explain the problem with choice, we need an asynchronous version (because our translation 
// appropriates the return value to track the choice). Moreover once we switch to the async 
// version we *have* to embrace the uncomfortable encoding of internal behaviour as "services": 
// consider EXEC, where the "request" part needs to specify the eventual state, but that depends 
// on a choice made internally. So now we need send/receive halves for every request and response,
// internal sequencing, etc. as per the current translation.

typestate Redis_Server_Async {
	session
		Init = {
			String[] receiveWATCH(): Watching 
		}
		
		Watching = {
			void receiveGET_request(String): Watching,
			void sendWATCH(String[]): Watching,
			void sendMULTI(): Queued
		}

		Waiting_Watching_GET = {
			String receiveGET_response(String): Watching 
		}
		
		Waiting_Queued_EXEC = {
			Result receiveEXEC_request(): <OK: end, FAIL: Queued>
		}
}

typestate Redis_Client_Async {
	session
		Init = {
           void sendWATCH(String[]): Watching
		}
	where
		Watching = {
			void sendGET_request(String): Watching,
			void sendWATCH(String[]): Watching,
			void sendMULTI(): Queued
		}
		
		Queued = {
		    void sendSET(String, String): Queued,
			void sendDISCARD(): end,
			void sendEXEC_request(): Queued
		}
}
