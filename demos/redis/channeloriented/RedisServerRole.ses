package demos.redis.channeloriented;

class RedisServerRole typestate RedisServerProtocol {
    String[] receiveWATCH() {
    	return null;
    }

	WatchingLabel receiveLabel_Watching() {
		return null;
	}

	String receiveArg_GET () {
		return null;
	}

	void sendGET_response(String v) {
	}
		
	String[] receiveArg_WATCH() {
		return null;
	}
		
	String receiveArg0_SET() {
		return null;
	}		
		
	String receiveArg1_SET() {
		return null;
	}		
		
	QueuedLabel receiveLabel_Queued() {
		return null;
	}
		
	ResultLabel sendEXEC_response(int label) {
		return null;
	}

	// The implementation of all services must be provided essentially inline as straight-line code that
	// waits for labels to be received and dispatches on them in order to execute the relevant bit of 
	// code. In this sense it is an unorthodox programming model for Java.
	
	public static void main (String[] args) {
		RedisServerRole redis = new RedisServerRole();
		String[] ks = redis.receiveWATCH();
		WATCHING: do {
			switch (redis.receiveLabel_Watching().getEnum()) {
				case WatchingLabel.GET:
					String k = redis.receiveArg_GET();
					redis.sendGET_response(""); // TODO
					continue WATCHING;
				case WatchingLabel.WATCH:
					String[] ks2 = redis.receiveArg_WATCH();
					continue WATCHING;
				case WatchingLabel.MULTI:
					QUEUED: do {
						switch (redis.receiveLabel_Queued().getEnum()) {
							case QueuedLabel.SET:
								String k2 = redis.receiveArg0_SET();
								String v = redis.receiveArg1_SET();
								continue QUEUED;
							case QueuedLabel.DISCARD:
								break WATCHING;
							case QueuedLabel.EXEC:
								switch (redis.sendEXEC_response(0).getEnum()) { // TODO
									case ResultLabel.OK:
										break WATCHING;
									case ResultLabel.FAIL:
										continue QUEUED;
								}
						}
					} while (false);
			}
		} while (false);
	}
}
