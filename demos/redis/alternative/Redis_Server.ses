package demos.redis.alternative;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label, optionally followed by the sending
// of the payload. 

// This is heavy-handed compared to modelling choice simply as the invocation of a method,
// as we do in the hand-coded typestate definition (call it S). S can be used to check that 
// a server impl is able to handle all the incoming messages it should be able to
// handle, but NOT to check that it sends all the outgoing messages that it should. That 
// can't be expressed (directly) in typestate.

// However, S _can _ also be used to check that any _client_ only sends messages the server 
// can accept. In summary: S describes a service, and we can check existence of provision of
// service (on the server) and (dually) legality of consumption of service (on the client).

// The alternative typestate given below (call it S') can be used to check BOTH that a server
// impl is able to handle all the incoming messages that it should, AND that it sends all the
// outgoing messages that it should. We express the latter in typestate by exposing the 
// obligation to send sessages as additional _services_: in effect we exploit duality to
// encode liveness as [safety + requirement to consume available services].

// However, S' _cannot_ be used to check any properties of the client, basically because the
// client never uses S' (it is never typechecked against the dual of S'). Rather, the local
// Scribble protocol from which S' was derived has a dual (the client's local projection), and the
// typestate encoding of that dual is used to typecheck the client. But the encodings themselves
// are not dual at the level of the typestate language, although in some semantic sense they are 
// dual.

// Some relatively minor additional points about the translation:
		
// At the sender, we have to return as a result the same choice label we were passed as an 
// argument, so that the sender can dispatch on it to continue with the rest of the protocol. 
// But this is weird because the client already knows what choice it made. (Nor does it
// make sense to insist that the client specify a continuation for choices it didn't make.)

// In the specification of the translation, we currently pass the labels as strings rather than 
// enums. (Our compiler doesn't handle enums properly yet; ints would probably be an improvement 
// over strings in the meantime, since ints/enums are already semi-conflated.)

typestate Redis_Server {
	session
		Init = {
           String[] receiveWATCH(): Watching
		}
	where
		Watching = {
			WatchingLabel receiveLabel_Watching(): <
				GET_request: ReceiveArg_Watching_GET,
				WATCH: ReceiveArg_Watching_WATCH,
				MULTI: Queued
			>
		}
		
		ReceiveArg_Watching_GET = {
			String receiveArg_GET(): Responding_Watching_GET
		}
		
	 	Responding_Watching_GET = {
			void sendGET_response(String): Watching
	 	}
	 	
	 	ReceiveArg_Watching_WATCH = {
	 		String[] receiveArg_WATCH(): Watching
	 	}
		
		Queued = {
			QueuedLabel receiveLabel_Queued(): <
		    	SET: ReceiveArg0_Queued_SET,
				DISCARD: end,
				EXEC: Responding_Queued_EXEC
			>
		}
		
		ReceiveArg0_Queued_SET = {
			String receiveArg0_SET(): ReceiveArg1_Queued_SET 
		}
		
		ReceiveArg1_Queued_SET = {
			String receiveArg1_SET(): Queued 
		}
		
		Responding_Queued_EXEC = {
			// Here's an example of the need to take a label as argument and then return it.
			// Unfortunately our compiler won't less us pass ResultLabel as the type of the
			// label (this problem will go away when we support enums properly).
			ResultLabel sendEXEC_response(int): <
				OK:end, 
				FAIL:Queued
			>
		}
}
