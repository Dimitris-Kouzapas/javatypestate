package demos.redis.alternative;

// This is roughly what we would end up with our current Scribble-to-typestate translation.
// We represent choice as the explicit sending of a label, optionally followed by the sending
// of the payload. This is heavy-handed compared to modelling choice simpy as the invocation
// of a method, but unfortunately the translation to typestate is unable to represent internal
// actions.		
		
// An additional oddity as is that, at the sender, we have to return as a result the same choice label
// we were passed as an argument, so that the sender can dispatch on it to continue with the rest of
// the protocol. But this is weird because the sender already knows what choice it made. Nor does it
// make sense to insist that the client specify a continuation for choices it didn't make.

// (In the current translation spec, we pass the labels as strings rather than enums, but this is a 
// minor detail.)

typestate Redis_Server {
	session
		Init = {
           String[] receiveWATCH(): Watching
		}
	where
		Watching = {
			WatchingLabel receiveLabel_Watching(): <
				GET_request: ReceiveArg_Watching_GET,
				WATCH: ReceiveArg_Watching_WATCH,
				MULTI: Queued
			>
		}
		
		ReceiveArg_Watching_GET = {
			String receiveArg_GET(): Responding_Watching_GET
		}
		
	 	Responding_Watching_GET = {
			void sendGET_response(String): Watching
	 	}
	 	
	 	ReceiveArg_Watching_WATCH = {
	 		String[] receiveArg_WATCH(): Watching
	 	}
		
		Queued = {
			QueuedLabel receiveLabel_Queued(): <
		    	SET: ReceiveArg0_Queued_SET,
				DISCARD: end,
				EXEC: Responding_Queued_EXEC
			>
		}
		
		ReceiveArg0_Queued_SET = {
			String receiveArg0_SET(): ReceiveArg1_Queued_SET 
		}
		
		ReceiveArg1_Queued_SET = {
			String receiveArg1_SET(): Queued 
		}
		
		Responding_Queued_EXEC = {
			// Here's an example of the need to take a label as argument and then return it.
			// Unfortunately our compiler won't less us pass ResultLabel as the type of the
			// label (this problem will go away when we support enums properly).
			ResultLabel sendEXEC_response(int): <
				OK:end, 
				FAIL:Queued
			>
		}
}
